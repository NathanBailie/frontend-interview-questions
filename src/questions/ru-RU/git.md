<a href="../../../README.md">← Назад</a>

<div align="center">
  <img src="../../../src/assets/icons/icons-for-titles/git.png">
  <h2>Вопросы по GIT</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>Git</b>?</span></summary>
<br />

**Git** — это распределённая система управления версиями, позволяющая хранить разные версии кода, к которым можно вернуться при необходимости, работая в команде.

Он фиксирует историю изменений, поддерживает параллельную работу в ветках и обеспечивает удобное объединение кода.

</details>

---

<details>
<summary><span>2. В каких состояниях может находиться файл?</span></summary>
<br />

В Git файл может находиться в следующих состояниях:

- **Untracked** — новый файл, о котором Git пока не знает. Файл находится в рабочей директории, но не добавлен под версионный контроль.
- **Tracked** — файл, который отслеживается Git. Tracked файлы могут быть в трёх состояниях:
  - **Unmodified** — файл не изменялся с момента последнего коммита
  - **Modified** — файл был изменён, но изменения ещё не подготовлены для коммита
  - **Staged** — изменения файла добавлены в индекс и готовы для создания коммита

После создания коммита все staged файлы переходят в состояние unmodified.

</details>

---

<details>  
<summary><span>3. Как перевести файл в индексированное состояние?</span></summary>  
<br />

Чтобы добавить файл в индекс (**staged** состояние), используется команда `git add`:

- `git add filename.txt` — добавить конкретный файл
- `git add .` — добавить изменённые файлы в текущей директории, но **не затрагивает удалённые файлы**
- `git add --all` / `git add -A` — добавить **все изменения**, включая удалённые файлы
- `git add *.js` — добавить все файлы с определённым расширением
- `git add directory/` — добавить все файлы из определённой директории

После выполнения этой команды файлы будут подготовлены для создания коммита.

Также можно использовать дополнительные режимы:

- `git add -i` — интерактивный режим, позволяющий выборочно добавлять изменения
- `git add -p` — позволяет индексировать отдельные части изменений (hunks) в файлах

</details>

---

<details>  
<summary><span>4. Как зафиксировать изменения?</span></summary>  
<br />

Для фиксации изменений в Git используется команда `git commit`:

- `git commit -m "сообщение"` — создать коммит с указанным сообщением.
- `git commit` — откроется текстовый редактор для написания сообщения.
- `git commit -a -m "сообщение"` — автоматически добавляет в индекс и коммитит **только отслеживаемые файлы**, но не включает новые (`untracked`).

</details>

---

<details>
<summary><span>5. Как клонировать  репозиторий на свою локальную машину?</span></summary>
<br />

Для клонирования репозитория используется команда `git clone`:

- `git clone <url>` — клонирует репозиторий в текущую директорию.
- `git clone <url> <directory>` — клонирует репозиторий в указанную директорию, **создавая её автоматически**, если она не существует.

URL может быть HTTPS или SSH адресом репозитория.

</details>

---

<details>
<summary><span>6. Как отправить изменения на удаленный репозиторий?</span></summary>
<br />

Для отправки изменений на удаленный репозиторий используется команда `git push`:

- `git push origin main` — отправляет изменения из локальной ветки main в одноименную ветку удаленного репозитория origin
- `git push` — отправляет изменения в текущую ветку, если настроена связь с удаленным репозиторием
- `git push -u origin branch-name` — отправляет новую ветку в удаленный репозиторий и устанавливает отслеживание
- `git push --force` — принудительно перезаписывает историю удаленного репозитория (использовать с осторожностью!)
- `git push --tags` — отправляет теги в удаленный репозиторий

</details>

---

<details>  
<summary><span>7. В чем опасность использования команды <b>git push --force?</b></span></summary>  
<br />

Команда **`git push --force`** принудительно перезаписывает историю удалённого репозитория, **игнорируя** возможные изменения, сделанные другими разработчиками. Это может привести к потере их коммитов и усложнить восстановление данных.

Вместо неё лучше использовать **`git push --force-with-lease`**, которая проверяет наличие новых коммитов на удалённой ветке перед перезаписью. Это снижает риск потери изменений, если кто-то уже внес обновления.

</details>

---

<details>
<summary><span>8. Для чего нужна команда <b>set-upstream</b>?</span></summary>
<br />

Команда `git branch --set-upstream-to` (или `-u` в сокращенном виде) используется для установки связи между локальной и удаленной ветками. После установки этой связи можно использовать сокращенные команды `git pull` и `git push` без указания имени удаленного репозитория и ветки.

</details>

---

<details>
<summary><span>9. В чем разница между <b>git pull</b> и <b>git fetch</b>?</span></summary>
<br />

`git fetch` только загружает изменения с удаленного репозитория, но не применяет их к рабочей копии. `git pull` загружает изменения и сразу же пытается слить их с текущей веткой (фактически выполняет `git fetch` + `git merge`).

</details>

---

<details>
<summary><span>10. Что такое <b>pull-request</b>?</span></summary>
<br />

Pull request (PR) - это механизм для предложения изменений в репозиторий. Разработчик создает отдельную ветку, вносит в нее изменения и запрашивает их включение в основную ветку через PR. Это позволяет провести код-ревью, обсудить изменения и безопасно внести правки в проект.

</details>

---

<details>  
<summary><span>11. Как можно оформить текст коммита?</span></summary>  
<br />

Хорошо оформленный коммит должен быть **понятным, кратким и информативным**, чтобы другие разработчики могли легко понять изменения. Один из стандартных подходов — **Conventional Commits**, который задаёт чёткую структуру:

### **Типы коммитов в Conventional Commits:**

- **feat** — добавление новой функциональности
- **fix** — исправление ошибки
- **refactor** — улучшение кода без изменения функциональности
- **docs** — обновление документации
- **style** — исправления форматирования (например, пробелы, отступы)
- **test** — добавление или изменение тестов
- **chore** — технические задачи, не влияющие на код (например, обновление зависимостей)

</details>

---

<details>
<summary><span>12. Как посмотреть историю коммитов?</span></summary>
<br />

- `git log` — базовый вывод с полной информацией о коммитах
- `git log --oneline` — компактный вывод (одна строка на коммит)
- `git log --graph` — визуализация веток в виде графа
- `git log -p` — показывает изменения в каждом коммите
- `git log --author="name"` — фильтрация по автору
- `git log --since="2 weeks ago"` — фильтрация по дате
- `git log <file>` — история изменений конкретного файла

Также можно комбинировать опции, например: `git log --oneline --graph` для компактного отображения графа веток.

</details>

---

<details>
<summary><span>13. Что такое <b>HEAD</b>?</span></summary>
<br />

HEAD - это специальный указатель в Git, который ссылается на текущий коммит в активной ветке. Это своего рода "курсор", показывающий, где вы находитесь в истории репозитория.

Основные характеристики HEAD:

- Обычно указывает на последний коммит текущей ветки
- При переключении между ветками HEAD автоматически перемещается
- Может быть "отсоединён" (detached HEAD) при переключении на конкретный коммит
- Используется как ссылка в командах, например `git reset HEAD~1` для отмены последнего коммита

HEAD можно представить как закладку в книге - она показывает, где вы сейчас находитесь в истории проекта.

</details>

---

<details>
<summary><span>14. Чем отличаются <b>^</b> и <b>~</b>?</span></summary>
<br />

- **Тильда (`~`)** — это ссылка на коммит на _N_ поколений назад по первой родительской линии.
- **Каретка (`^`)** — это указатель на конкретного родителя коммита (например, первого или второго в merge-коммите).

</details>

---

<details>
<summary><span>15. Как посмотреть в каком состоянии находится репозиторий?</span></summary>
<br />

Команда `git status` показывает текущее состояние репозитория:

- Отображает текущую ветку
- Показывает неотслеживаемые файлы (untracked)
- Показывает измененные файлы (modified)
- Показывает файлы, добавленные в индекс (staged)
- Показывает информацию о состоянии относительно удаленного репозитория

Дополнительные опции:

- `git status -s` или `git status --short` — компактный вывод
- `git status -b` — дополнительно показывает информацию о ветке
- `git status -u` — показывает неотслеживаемые файлы в директориях

</details>

---

<details>
<summary><span>16. Как изменить последний коммит?</span></summary>
<br />

Для изменения последнего коммита используется команда `git commit --amend`:

- Позволяет изменить сообщение последнего коммита
- Добавить новые изменения в последний коммит
- Изменить автора коммита

</details>

---

<details>
<summary><span>17. Как отменить коммит?</span></summary>
<br />

Существует несколько способов отменить коммит:

1. **git reset** - отменяет коммиты и перемещает HEAD:

   - `git reset --soft HEAD~1` - отменяет коммит, сохраняя изменения в индексе
   - `git reset --mixed HEAD~1` - отменяет коммит и очищает индекс (по умолчанию)
   - `git reset --hard HEAD~1` - полностью удаляет коммит и все изменения

2. **git revert** - создает новый коммит, который отменяет изменения предыдущего:

   - `git revert HEAD` - отменяет последний коммит
   - `git revert <commit-hash>` - отменяет конкретный коммит

</details>

---

<details>
<summary><span>18. Чем отличаются команды <b>git reset</b> и <b>git revert</b>?</span></summary>
<br />

- `reset` изменяет историю, удаляя коммиты
- `revert` сохраняет историю, добавляя новый коммит, поэтому безопаснее для совместной работы

</details>

---

<details>
<summary><span>19. Как вернуть удаленные коммиты?</span></summary>
<br />

Удаленные коммиты можно восстановить с помощью команды `git reflog` и `git reset`:

1. `git reflog` показывает журнал всех изменений HEAD, включая удаленные коммиты
2. Найдите хеш нужного коммита в выводе reflog
3. Используйте `git reset --hard <commit-hash>` для восстановления состояния

</details>

---

<details>
<summary><span>20. Как создать новую ветку?</span></summary>
<br />

Существует несколько способов создания новой ветки:

1. **git branch** - создает новую ветку, но не переключается на нее:

   - `git branch <branch-name>` - создает ветку от текущего коммита
   - `git branch <branch-name> <commit-hash>` - создает ветку от указанного коммита

2. **git checkout** - создает и переключается на новую ветку:

   - `git checkout -b <branch-name>` - создает ветку от текущего коммита и переключается на нее
   - `git checkout -b <branch-name> <commit-hash>` - создает ветку от указанного коммита

3. **git switch** (Git 2.23+) - современная альтернатива checkout:
   - `git switch -c <branch-name>` - создает и переключается на новую ветку
   - `git switch -c <branch-name> <commit-hash>` - создает ветку от указанного коммита

</details>

---

<details>
<summary><span>21. Как перенести коммиты из одной ветки в другую?</span></summary>
<br />

1. **git cherry-pick** - копирует отдельные коммиты:

   ```bash
   git cherry-pick <commit-hash>
   ```

2. **git merge** - объединяет ветки, перенося все коммиты:

   ```bash
   git checkout target-branch
   git merge source-branch
   ```

3. **git rebase** - переносит коммиты, перестраивая историю:
   ```bash
   git checkout feature-branch
   git rebase main
   ```

</details>

---

<details>
<summary><span>22. В чем разница между <b>rebase</b> и <b>merge</b>?</span></summary>
<br />

1. **git merge** - создается новый коммит слияния, сохраняющий историю обеих веток
2. **git rebase** - переписывает историю, делая ее линейной, но изменяет хеши коммитов

</details>

---

<details>
<summary><span>23. Какие проблемы могут возникнуть при использовании <b>git rebase</b>?</span></summary>
<br />

1. **Конфликты слияния** - при rebase могут возникнуть конфликты, которые нужно разрешать вручную для каждого коммита

2. **Изменение истории** - rebase переписывает историю коммитов, что может создать проблемы при работе в команде:

   - Изменяются хеши коммитов
   - Усложняется отслеживание изменений
   - Возможны проблемы при push, требуется force push

3. **Сложности при откате** - из-за переписывания истории сложнее откатить изменения

4. **Проблемы с длинными ветками** - чем больше коммитов ребазируется, тем выше вероятность конфликтов

5. **Риск потери данных** - неправильное использование force push после rebase может привести к потере изменений других разработчиков

</details>

---

<details>  
<summary><span>24. Что находится в папке <b>objects</b>?</span></summary>  
<br />

В папке **`objects`** внутри `.git` хранятся все объекты Git — это **основа всей истории репозитория**.

Она хранит **все коммиты, файлы, деревья и теги**, сжатые по алгоритму zlib, а их имя — это **SHA-1 хеш** содержимого.

### Типы объектов:

- **Blob** — хранит содержимое файлов.
- **Tree** — представляет структуру директорий, содержит ссылки на blob'ы и другие tree.
- **Commit** — фиксирует изменения, ссылается на дерево (`tree`) и родителей.
- **Tag** — аннотированные теги, например для версий релизов.

**Git не хранит файлы напрямую** — он сохраняет **снимки состояния (snapshots)**, а все объекты лежат в `.git/objects`.

</details>

---

<details>
<summary><span>25. Что делает команда <b>git cat-file</b>?</span></summary>
<br />

Команда **`git cat-file`** позволяет просматривать содержимое, тип и размер объектов Git (blob, tree, commit, tag) по их SHA-1 хешу.

</details>

---

<details>
<summary><span>26. Что делает команда <b>git show</b>?</span></summary>
<br />

Команда **`git show`** выводит детальную информацию о коммите, включая авторство, дату, изменения файлов и разницу (`diff`) между текущей и предыдущей версией

</details>

---

<details>
<summary><span>27.Для чего нужны <b>теги</b>?</span></summary>
<br />

**Теги в Git** позволяют создавать метки на важных коммитах, чаще всего для обозначения версий или релизов. Они упрощают навигацию и помогают быстро переключаться на нужные точки в истории проекта.

</details>

---

<details>
<summary><span>28. Как работает сборка мусора при запуске <b>git gc</b>?</span></summary>
<br />

В Git сборка мусора (`git gc`) основана на концепции **достижимости**:

- **Достижимые объекты** (коммиты, деревья, блобы) — те, на которые есть ссылки (HEAD, ветки, теги).
- **Недостижимые объекты** — не имеющие ссылок и не используемые в истории репозитория.

`git gc` удаляет **недостижимые объекты**, если они хранятся дольше определённого времени.

</details>

---

<details>
<summary><span>28. Для чего нужен <b>git stash</b>?</span></summary>
<br />

**Git stash** позволяет временно сохранить незакоммиченные изменения и вернуть рабочую директорию в "чистое" состояние. Это полезно, когда нужно:

- Быстро переключиться на другую ветку, не создавая коммит
- Отложить текущие изменения для работы над срочной задачей
- Сохранить изменения, которые пока не готовы для коммита

Сохранённые изменения можно позже восстановить командой `git stash pop` или `git stash apply`.

</details>

---

<details>
<summary><span>29. Что делает команда <b>git clean</b>?</span></summary>
<br />

Команда **`git clean`** удаляет неотслеживаемые файлы из рабочей директории. Это включает:

- Новые файлы, которые еще не были добавлены в индекс
- Файлы, созданные в процессе сборки проекта
- Временные файлы

Основные опции:

- `-n` (--dry-run) - показывает, какие файлы будут удалены, без реального удаления
- `-f` (--force) - принудительное удаление файлов
- `-d` - также удаляет неотслеживаемые директории
- `-x` - удаляет игнорируемые файлы (указанные в .gitignore)

⚠️ Удаленные файлы невозможно восстановить!

</details>

---

<details>
<summary><span>30. Какие вы знаете методики ветвления?</span></summary>
<br />

1. Git Flow
2. Trunk-Based

</details>

---

<details>
<summary><span>31. Как происходит разработка по <b>Git Flow</b>?</span></summary>
<br />

**Git Flow** - это модель ветвления с двумя основными ветками:

- **master/main** - стабильная версия продукта
- **develop** - ветка для разработки

И тремя вспомогательными:

- **feature/** - для новых функций (от develop)
- **hotfix/** - для срочных исправлений (от master)
- **release/** - для подготовки релиза (от develop)

Процесс:

1. Разработка ведется в feature-ветках
2. Готовые фичи вливаются в develop
3. Для релиза создается release-ветка
4. После тестирования релиз вливается в master и develop

</details>

---

<details>
<summary><span>32. Как происходит разработка по <b>Trunk-Based</b>?</span></summary>
<br />

**Trunk-Based Development** - это подход к ветвлению, где основная разработка ведется в главной ветке (trunk/master/main).

Основные принципы:

- Все разработчики коммитят напрямую в master
- Короткоживущие feature-ветки (1-2 дня)
- Частые коммиты небольших изменений
- Непрерывная интеграция (CI)
- Feature Toggles для отключения незавершенных функций

Преимущества:

- Быстрая интеграция кода
- Меньше конфликтов слияния
- Проще поддерживать код
- Быстрые релизы

Этот подход хорошо подходит для небольших команд и частых релизов.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />


</details>

--- -->
