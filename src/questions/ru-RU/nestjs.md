<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/nestjs.png">
  <h2>NestJs</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>NestJs</b>?</span></summary>
<br />

**NestJS** - это **фреймворк для Node.js**, построенный на **TypeScript** и вдохновлённый архитектурой **Angular**. Он помогает создавать **масштабируемые серверные приложения** с использованием **модулей**, **контроллеров** и **сервисов**, поддерживает **инъекцию зависимостей** и легко интегрируется с **Express** или **Fastify**.

</details>

---

<details>
<summary><span>2. Что такое <b>middleware</b>?</span></summary>
<br />

**Middleware** - это **функция**, которая **перехватывает запрос** между клиентом и обработчиком (контроллером). Она может выполнять **логирование**, **аутентификацию**, **валидацию**, изменять запрос или завершать его до передачи дальше. В NestJS подключается через `@Middleware()` или `app.use()`.

</details>

---

<details>
<summary><span>3. В чём <b>отличие Nest middleware от Express</b>?</span></summary>
<br />

**Express middleware** - это просто функция `(req, res, next)`, подключаемая вручную через `app.use()`.

**NestJS middleware** - это **класс с методом `use()`**, который можно подключать через **модули** и **`MiddlewareConsumer`**, поддерживает **инъекцию зависимостей** и лучше интегрируется в архитектуру Nest.

</details>

---

<details>
<summary><span>4. Что такое <b>dependency injection</b>?</span></summary>
<br />

**Dependency Injection (DI)** - это паттерн, при котором **зависимости (сервисы, классы, данные)** передаются в компонент **извне**, а не создаются внутри него. Это упрощает **тестирование**, **расширяемость** и **слабую связанность** компонентов. В NestJS реализуется через **декораторы** и **контейнер инверсии управления**.

</details>

---

<details>
<summary><span>5. Какие есть <b>декораторы в Nest.js</b>?</span></summary>
<br />

В NestJS используются декораторы для объявления компонентов и их поведения:

- **@Module** - описывает модуль и его зависимости
- **@Injectable** - делает класс доступным для DI
- **@Controller** - определяет контроллер и его маршруты
- **@Get**, **@Post**, **@Put**, **@Delete** - маршруты HTTP
- **@Body**, **@Param**, **@Query**, **@Headers** - доступ к частям запроса
- **@UseGuards**, **@UseInterceptors**, **@UseFilters** - подключение guard'ов, интерсепторов и фильтров
- **@Catch** - обработка исключений
- **@Pipe** - создание кастомных пайпов

</details>

---

<details>
<summary><span>6. Что такое <b>event emitter</b>?</span></summary>
<br />

В **NestJS** можно использовать **EventEmitter** через пакет `@nestjs/event-emitter`. Он позволяет создавать **события** и **слушателей**, чтобы компоненты могли **реагировать на действия** без прямой связи между собой. Это удобно для **логирования**, **уведомлений**, **внутренней коммуникации** между модулями.

</details>

---

<details>
<summary><span>7. <b>Гарды, пайпы, интерсепторы</b></span></summary>
<br />

В NestJS эти элементы обрабатывают запросы на разных этапах:

- **Гарды (Guards)** - решают, можно ли выполнять маршрут (например, проверка авторизации). Используют `@UseGuards`.
- **Пайпы (Pipes)** - трансформируют и валидируют входные данные (`@Body`, `@Param` и др.). Используют `@UsePipes`.
- **Интерсепторы (Interceptors)** - перехватывают запросы/ответы, добавляют логику (логирование, кеширование, тайминг). Используют `@UseInterceptors`.

Все три - мощные инструменты для **предобработки**, **безопасности** и **расширения поведения** маршрутов.

</details>

---

<details>
<summary><span>8. Что раньше применяется - guard или middleware?</span></summary>
<br />

**Middleware** применяется **раньше**, чем **guard**.  
Порядок обработки запроса в NestJS:

1. **Middleware** - на уровне `app.use()` или `MiddlewareConsumer`, обрабатывает запрос до маршрутизации.
2. **Guards** - применяются после маршрутизации, решают, можно ли продолжить выполнение маршрута.
3. **Interceptors**, **Pipes**, **Controllers** - идут далее по цепочке.

Таким образом, middleware - это первый уровень логики, например, для логирования или парсинга, а guard - для авторизации и доступа.

</details>

---

<details>
<summary><span>9. Какой <b>жизненный цикл запроса в Nest</b>?</span></summary>
<br />

Жизненный цикл запроса в NestJS проходит через несколько этапов:

1. **Middleware** — первый перехват запроса, например, логирование, парсинг тела.
2. **Guards** — проверка доступа, авторизация.
3. **Interceptors (до)** — логика до выполнения контроллера (тайминг, трансформация).
4. **Pipes** — валидация и трансформация входных данных.
5. **Controller** — основной обработчик запроса.
6. **Service** — бизнес-логика, вызываемая из контроллера.
7. **Interceptors (после)** — постобработка ответа.
8. **Exception Filters** — обработка ошибок, если они возникли.

Этот цикл позволяет гибко управлять поведением запроса на каждом этапе.

</details>

---

<details>
<summary><span>10. Что использует Nest для <b>обработки ошибок</b>, если на каком-то этапе произошла ошибка?</span></summary>
<br />

NestJS использует **Exception Filters** для централизованной обработки ошибок. По умолчанию применяется встроенный `HttpException`, который возвращает структурированный ответ с кодом и сообщением.

Можно также создать **кастомные фильтры** с помощью декоратора `@Catch()`, чтобы перехватывать специфические ошибки и возвращать нужный формат ответа.  
Фильтры можно применять:

- глобально (`app.useGlobalFilters()`)
- на уровне контроллера
- на уровне метода

Это позволяет гибко управлять поведением приложения при возникновении исключений.

</details>

---

<details>
<summary><span>11. Как работает <b>reflect-metadata</b>?</span></summary>
<br />

`reflect-metadata` — это библиотека, которая позволяет **сохранять и считывать метаданные** у классов, методов и параметров.  
Она используется в **TypeScript** и активно применяется в **NestJS** для работы **декораторов** (`@Injectable()`, `@Controller()` и др.).

Примеры:

- `Reflect.defineMetadata(key, value, target)` — сохраняет метаданные
- `Reflect.getMetadata(key, target)` — получает их

Благодаря этому Nest может автоматически **связывать зависимости**, **строить маршруты** и **проводить валидацию**.

</details>

---

<details>
<summary><span>12. Как решить <b>проблему циклической зависимости</b> в Nest.js?</span></summary>
<br />

Циклическая зависимость возникает, когда два или более провайдера зависят друг от друга напрямую или через цепочку. В NestJS её можно решить с помощью:

- **`forwardRef(() => Class)`** — позволяет отложить разрешение зависимости до момента, когда все модули будут загружены.

  Пример:

  ```ts
  @Injectable()
  export class ServiceA {
  	constructor(
  		@Inject(forwardRef(() => ServiceB)) private serviceB: ServiceB
  	) {}
  }
  ```

- **Вынос общей логики в отдельный модуль** — помогает разорвать цикл зависимостей.
- **Рефакторинг архитектуры** — иногда циклы указывают на слишком тесную связанность компонентов.

</details>

---

<details>
<summary><span>13. Для чего используется <b>CQRS паттерн</b>?</span></summary>
<br />

**CQRS (Command Query Responsibility Segregation)** — это паттерн, который разделяет операции **чтения (Query)** и **изменения данных (Command)** на разные модели и обработчики.

Он применяется для:

- 🔹 **Масштабируемости** — чтение и запись можно оптимизировать независимо друг от друга
- 🔹 **Упрощения бизнес-логики** — команды изменяют состояние, но не возвращают данные
- 🔹 **Чёткого разделения ответственности** — код становится чище и легче поддерживать
- 🔹 **Гибкости в работе с данными** — можно использовать разные источники для чтения и записи

В NestJS CQRS реализуется через отдельные **CommandHandlers** и **QueryHandlers**, обычно с помощью пакета `@nestjs/cqrs`.

</details>

---

<details>
<summary><span>14. Зачем <b>entity</b> в Nest?</span></summary>
<br />

**Entity** — это класс, описывающий **структуру таблицы в базе данных**.  
Он используется вместе с **TypeORM**, **Prisma** или другим ORM для:

- 🔹 Определения полей и связей (колонки, типы, отношения)
- 🔹 Связи между базой данных и TypeScript-кодом
- 🔹 Автоматической генерации SQL-запросов
- 🔹 Валидации и трансформации данных на уровне модели

В NestJS entity — это основа для работы с **репозиториями**, **сервисами** и **DTO**, обеспечивая чистую архитектуру и типизацию.

</details>

---

<details>
<summary><span>15. Что такое <b>I/O container</b> в Next.js?</span></summary>
<br />

**I/O container** — это компонент или модуль, который управляет **вводом и выводом данных** между клиентом и сервером. Он может:

- 🔹 Принимать входные данные (запросы, параметры, формы)
- 🔹 Обрабатывать их (вызовы API, запросы к базе данных)
- 🔹 Возвращать результат (рендер страницы, JSON-ответ и т.д.)

В новых версиях Next.js роль I/O-контейнера часто выполняют **Server Actions** и **Route Handlers**, связывая клиентские компоненты с серверной логикой.

</details>

---

<!-- <details>
<summary><span> <b></b>?</span></summary>
<br />


</details>

---
-->
