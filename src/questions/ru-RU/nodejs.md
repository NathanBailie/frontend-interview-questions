<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/nodejs.png">
  <h2>Node.js</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>Node.js</b>?</span></summary>
<br />

Node.js — это среда выполнения JavaScript вне браузера, построенная на движке V8. Позволяет создавать серверные приложения, обрабатывающие множество запросов асинхронно.

</details>

---

<details>
<summary><span>2. Из чего состоит Node.js?</span></summary>
<br />

- **V8** — движок, выполняющий JavaScript
- **libuv** — библиотека для **асинхронного ввода-вывода** и работы с **потоками**
- **встроенные модули** — такие как **fs**, **http**, **path**
- **npm** — менеджер пакетов для установки и управления зависимостями

</details>

---

<details>
<summary><span>3. За что отвечает движок <b>V8</b>?</span></summary>
<br />

**V8** — это высокопроизводительный движок от Google, который **компилирует JavaScript в машинный код**. Он отвечает за **выполнение и оптимизацию** JS-кода в Node.js.

</details>

---

<details>
<summary><span>4. За что отвечает библиотека <b>libuv</b>?</span></summary>
<br />

**libuv** — это библиотека, обеспечивающая **асинхронный ввод-вывод**, **работу с событиями**, **таймерами**, **сетевыми сокетами** и **пулом потоков**. Она позволяет Node.js эффективно обрабатывать множество операций без блокировки основного потока.

</details>

---

<details>
<summary><span>5. Какие есть <b>плюсы и минусы Event Loop</b> в Node.js?</span></summary>
<br />

**Плюсы**:

- **Асинхронность** — эффективно обрабатывает множество запросов без блокировки
- **Высокая производительность** при I/O-операциях
- **Простота масштабирования** через неблокирующую архитектуру

**Минусы**:

- **Ограниченность одного потока** — тяжёлые вычисления могут блокировать цикл
- **Сложность отладки** асинхронного кода
- **Низкая производительность** при CPU-интенсивных задачах

</details>

---

<details>
<summary><span>6. Node.js <b>однопоточный или многопоточный</b>?</span></summary>
<br />

Node.js — однопоточный по своей архитектуре: основной поток обрабатывает JavaScript-код, используя событийно-ориентированную модель.

Однако под капотом Node.js использует библиотеку <b>libuv</b>, которая <b>многопоточная</b>. Она отвечает за асинхронные операции, такие как файловая система, DNS, криптография и др.

По умолчанию libuv запускает <b>4 потока</b> в пуле. Максимальное количество потоков можно увеличить до <b>128</b> с помощью переменной окружения `UV_THREADPOOL_SIZE`.

Важно: если поступает больше задач, чем доступно потоков (например, 5 задач при 4 потоках), то 5-я задача будет <b>ожидать</b>, пока один из потоков освободится.

</details>

---

<details>
<summary><span>7. Что делает <b>демультиплексор событий</b>?</span></summary>
<br />

Демультиплексор событий — это механизм, который отслеживает множество источников событий (например, сокеты, таймеры, файловые дескрипторы) и определяет, какие из них готовы к обработке.

В контексте Node.js и libuv он:

- **ожидает события** от различных асинхронных операций;
- **выбирает готовые события** (например, завершение чтения файла или приход данных по сокету);
- **передаёт управление** соответствующим обработчикам (callback-функциям).

Таким образом, демультиплексор позволяет эффективно управлять множеством операций в одном потоке, не блокируя выполнение.

</details>

---

<details>
<summary><span>8. Опишите принцип работы цикла: <b>приложение - демультиплексор событий - очередь - Event Loop</b>?</span></summary>
<br />

Принцип работы можно описать поэтапно:

1. **Приложение** инициирует асинхронные операции (например, чтение файла, запрос к БД, таймер и т.д.).

2. Эти операции передаются в **демультиплексор событий** (например, `epoll`, `kqueue`, `IOCP` — в зависимости от платформы), который отслеживает, когда они завершатся или станут готовы к обработке.

3. Как только операция завершается, информация о ней помещается в **очередь готовых событий** (callback queue).

4. **Event Loop** (цикл событий) проверяет эту очередь и поочерёдно вызывает соответствующие **обработчики (callback-функции)**.

Таким образом, Event Loop обеспечивает неблокирующее выполнение кода, позволяя Node.js эффективно обрабатывать множество операций в одном потоке.

</details>

---

<details>
<summary><span>9. Как работает <b>планировщик потоков</b>?</span></summary>
<br />

Планировщик потоков в libuv управляет задачами, требующими блокирующего выполнения (например, `fs`, `crypto`, `dns`).

- Задачи ставятся в очередь.
- Потоки из пула (по умолчанию 4) берут задачи по очереди.
- Если все потоки заняты, новые задачи ждут, пока освободится один из них.
- После выполнения результат передаётся в Event Loop.

</details>

---

<details>
<summary><span>10. Что делает <b>оптимизацию</b> внутри Node.js?</span></summary>
<br />

Оптимизацию внутри Node.js обеспечивают:

- <b>V8</b> — движок, который компилирует JavaScript в машинный код и применяет JIT-оптимизации.
- <b>libuv</b> — эффективно управляет асинхронными задачами и потоками.
- <b>Event Loop</b> — минимизирует блокировки, распределяя задачи по фазам.
- <b>Hidden classes и inline caching</b> — ускоряют доступ к свойствам объектов.

Все эти компоненты работают вместе, чтобы повысить производительность и снизить задержки.

</details>

---

<details>
<summary><span>11. А что такое <b>деоптимизация</b>?</span></summary>
<br />

Деоптимизация — это процесс, при котором движок V8 отменяет ранее применённые JIT-оптимизации, если они оказались неэффективными или нарушены.

Причины могут быть такие:

- изменение структуры объекта;
- использование непредсказуемых типов;
- вызов редко используемых путей исполнения.

После деоптимизации код исполняется медленнее, но корректно. Это позволяет V8 сохранять баланс между скоростью и стабильностью.

</details>

---

<details>
<summary><span>12. Можно ли как-то <b>оценить производительность</b> по libuv?</span></summary>
<br />

Да, можно. Libuv не предоставляет встроенных метрик, но производительность можно оценить косвенно:

- через <b>время выполнения асинхронных задач</b> (например, `fs`, `crypto`);
- с помощью <b>профилирования Event Loop</b> (например, `perf_hooks`, `clinic.js`);
- по <b>задержкам выполнения колбэков</b> — рост задержек может указывать на перегрузку пула потоков.

Также можно увеличить `UV_THREADPOOL_SIZE` и сравнить результаты.

</details>

---

<details>
<summary><span>13. Как оценить, что приложение начинает тормозить? Есть ли метрика, которая покажет неэффективность операции?</span></summary>
<br />

Да, можно оценить через метрику <b>event loop lag</b> — задержку между циклами Event Loop.

Если задержка растёт, это может указывать на:

- блокирующие операции;
- перегрузку очереди;
- неэффективный код.

Для измерения можно использовать:

- <code>perf_hooks.monitorEventLoopDelay()</code>;
- инструменты вроде <code>clinic.js</code>, <code>node --trace-events</code>.

</details>

---

<details>
<summary><span>14. Node.js может исполнять TypeScript?</span></summary>
<br />

Напрямую — нет. Node.js исполняет только JavaScript.

Но можно использовать TypeScript с Node.js через:

- <b>трансляцию</b> в JavaScript (например, с помощью <code>tsc</code> или <code>esbuild</code>);
- <b>рантайм-обёртки</b> вроде <code>ts-node</code>, которые компилируют TypeScript на лету.

Таким образом, Node.js может работать с TypeScript, но через промежуточный слой.

</details>

---

<details>
<summary><span>15. Как Node.js <b>исполняет твой код</b>? Что происходит после того как JavaScript передаётся в Node.js?</span></summary>
<br />

После запуска JavaScript-код проходит через несколько этапов:

1. <b>V8</b> компилирует JavaScript в машинный код.
2. <b>Node.js</b> оборачивает код в модульную систему (CommonJS).
3. <b>Event Loop</b> запускается и начинает отслеживать асинхронные события.
4. <b>libuv</b> управляет системными операциями (I/O, таймеры, потоки).
5. Callback-функции попадают в очередь и исполняются по мере готовности.

Таким образом, Node.js превращает твой JS-код в асинхронное, неблокирующее приложение, используя V8, libuv и Event Loop.

</details>

---

<details>
<summary><span>16. Чем отличаются <b>CommonJS</b> модули и <b>ES-модули</b>?</span></summary>
<br />

<b>CommonJS</b> — старая система модулей, используется по умолчанию в Node.js:

- Синхронная загрузка: `require()`
- Экспорт через `module.exports`
- Работает только в среде Node.js
- Выполняется сразу при импорте (кэшируется)
- Использует копию значений при экспорте (а не ссылку на binding)

<b>ES-модули (ESM)</b> — современный стандарт JavaScript:

- Асинхронная загрузка: `import` / `export`
- Поддерживается как в браузере, так и в Node.js (с флагом или расширением `.mjs`)
- Поддерживает статический анализ и tree-shaking
- Экспортирует живые ссылки (bindings), обновляющиеся при изменении

Они несовместимы напрямую: нельзя использовать `require()` внутри ESM без обёртки.

</details>

---

<details>
<summary><span>17. Какие <b>уязвимости</b> есть при работе с Node.js?</span></summary>
<br />

Node.js-приложения могут быть уязвимы к:

- <b>Injection-атакам</b> — SQL, NoSQL, командная строка;
- <b>XSS</b> — особенно при работе с шаблонами и фронтендом;
- <b>Prototype Pollution</b> — изменение прототипов объектов;
- <b>DoS</b> — через блокирующие операции или большие payload'ы;
- <b>Утечкам данных</b> — при неправильной работе с cookies, JWT, CORS;
- <b>Уязвимостям зависимостей</b> — особенно при использовании устаревших npm-пакетов.

Для защиты важно:

- использовать <code>helmet</code>, <code>rate-limiter</code>, <code>validator</code>;
- регулярно проверять зависимости (<code>npm audit</code>);
- избегать блокирующего кода и несанитизированного ввода.

</details>

---

<details>
<summary><span>18. Что такое <b>AST</b> и какую функцию выполняет?</span></summary>
<br />

<b>AST</b> (Abstract Syntax Tree) — это абстрактное синтаксическое дерево, которое представляет структуру исходного кода в виде иерархии узлов.

Функции AST:

- позволяет компилятору или интерпретатору <b>анализировать</b> и <b>трансформировать</b> код;
- используется для <b>оптимизации</b>, <b>трансляции</b> (например, TypeScript в JavaScript), <b>линтинга</b>, <b>минификации</b>;
- помогает инструментам (например, Babel, ESLint) понимать, как устроен код на уровне конструкции.

AST — это промежуточное представление между исходным текстом и машинным кодом.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />


</details>

--- -->

<!--
Как ты масштабируешь Node.js приложение?
-->
