<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/js.png">
  <h2>Вопросы по JavaScript</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>JavaScript</b>?</span></summary>
<br />

JavaScript - это высокоуровневый интерпретируемый язык программирования, используемый для создания динамических и интерактивных элементов на веб-страницах

</details>

---

<details>
<summary><span>2. Почему мы используем именно JS для работы с браузерами?</span></summary>
<br />

- Единственный язык, поддерживаемый всеми браузерами без плагинов
- Динамическое обновление контента без перезагрузки страницы
- Асинхронные возможности с AJAX, Fetch API и Promises
- Гибкость как для простых анимаций, так и для сложных веб-приложений
- Богатая экосистема библиотек и фреймворков
- Прямое управление DOM и стилями

</details>

---

<details>
<summary><span>3. Какие типы данных существуют в JavaScript?</span></summary>
<br />

В JavaScript есть 8 типов данных: 7 примитивных типов и 1 объектный тип.

**Примитивные типы (не объекты):**

1. **Number** – для всех чисел (целых и с плавающей точкой)
2. **String** – последовательности символов
3. **Boolean** – `true` или `false`
4. **Null** – специальное значение, представляющее "ничего" или "пусто"
5. **Undefined** – переменная объявлена, но не присвоена
6. **Symbol** – уникальное и неизменяемое значение, в основном для ключей объектов
7. **BigInt** – для больших целых чисел за пределами `Number.MAX_SAFE_INTEGER`

**Объектный тип:**

8. **Object** – включает массивы, функции, даты, регулярные выражения, карты, множества и пользовательские объекты.

</details>

---

<details>
<summary><span>4. В чем разница между  <b>null</b> и <b>undefined</b>?</span></summary>
<br />

И **null**, и **undefined** представляют "ничего" или отсутствие значения, но используются по-разному:

- **undefined** автоматически присваивается JavaScript переменным, которые объявлены, но не инициализированы
- **null** - это тип данных, который программист явно присваивает для обозначения намеренного отсутствия значения

</details>

---

<details>
<summary><span>5. Какие способы объявления переменных существуют в JavaScript?</span></summary>
<br />

`var`:

- Функциональная область видимости
- Может быть переприсвоена
- Может быть переобъявлена
- Имеет всплытие, но значение undefined до инициализации
- Доступна неявная инициализация

`let`:

- Блочная область видимости
- Может быть переприсвоена
- Переобъявление приводит к ошибке
- Нет всплытия, ошибка при обращении до инициализации (временная мертвая зона)
- Доступна неявная инициализация

`const`:

- Блочная область видимости
- Нельзя переприсвоить, но свойства объекта можно изменять
- Переобъявление приводит к ошибке
- Нет всплытия, ошибка при обращении до инициализации (временная мертвая зона)
- Неявная инициализация приводит к ошибке

Необъявленная переменная:

- Глобальная область видимости (если не включен строгий режим)
- Может быть переприсвоена без ограничений (x = 10; x = 20;)
- Нет явного объявления (x = 5; вместо let x = 5;)
- Имеет всплытие, но может привести к ошибкам в строгом режиме
- Неявная инициализация возможна, но непредсказуема (y; создаст ReferenceError в строгом режиме)

</details>

---

<details>
<summary><span>6. Что такое <b>область видимости</b> в JavaScript?</span></summary>
<br />

Область видимости в JavaScript - это видимость и доступность переменных, функций и объектов в коде. Она определяет, где переменная может быть использована во время выполнения программы.

</details>

---

<details>
<summary><span>7. Что такое <b>Временная мертвая зона</b>?</span></summary>
<br />

Это период времени, в течение которого переменная существует в контексте, но не может быть использована до её инициализации. Это относится к переменным, объявленным с помощью `let` и `const`.

```javascript
console.log(a); // ❌ ReferenceError (TDZ)
let a = 5;
```

</details>

---

<details>
<summary><span>8. Какие типы областей видимости существуют в JavaScript?</span></summary>
<br />

- **Глобальная область видимости**: Переменные, объявленные вне любой функции или блока, доступны глобально во всем коде
- **Функциональная/Локальная область**: Переменные, объявленные внутри функции, доступны только внутри этой функции
- **Блочная область**: Переменные, объявленные через let и const, доступны только внутри блока, в котором они объявлены (например, в if или циклах)
- **Лексическая область**: Внутренние функции имеют доступ к переменным во внешней области видимости
- **Модульная область**: Переменные, объявленные в модуле, доступны только внутри этого модуля, если они явно не экспортированы

</details>

---

<details>
<summary><span>9. Какие способы создания функций вы знаете?</span></summary>
<br />

- **Объявление функции (Function Declaration)**

```javascript
function greet() {}
```

- **Функциональное выражение (Function Expression)**

```javascript
const greet = function () {};
```

- **Стрелочная функция (Arrow Function)**

```javascript
const greet = () => {};
```

- **Метод в объекте**

```javascript
const obj = {
	greet() {},
};
```

- **Метод в классе**

```javascript
class Greeter {
	greet() {}
}
```

- **Функция-конструктор (Function Constructor)**

```javascript
const greet = new Function();
```

</details>

---

<details>
<summary><span>10. Что такое <b>Function Declaration</b>?</span></summary>
<br />

Это способ объявления функции в JavaScript с использованием ключевого слова `function`.
Такая функция может быть вызвана до её определения благодаря механизму hoisting.

Основные особенности:

- Доступна в любом месте кода после объявления, даже если вызвана до него
- Её имя обязательно
- Не требует присваивания переменной, в отличие от Function Expression

</details>

---

<details>
<summary><span>11. Что такое <b>Function Expression</b>?</span></summary>
<br />

Это способ объявления функции в JavaScript, где функция создается внутри выражения и может быть присвоена переменной. В отличие от Function Declaration, она не поднимается, поэтому может быть вызвана только после её объявления.

Основные особенности:

- Могут использоваться анонимные функции (без имени)
- Функция не может быть вызвана до её объявления, иначе возникнет ошибка
- Удобно для передачи в колбэки и использования в стрелочных функциях

</details>

---

<details>
<summary><span>12. Что такое стрелочная функция?</span></summary>
<br />

Это компактный синтаксис для определения функций в JavaScript

Ключевые особенности:

- Не имеет собственного `this`, берет значение из внешнего контекста
- Не имеет собственного объекта `arguments`
- Не может использоваться как **конструктор** (нельзя вызвать с `new`)
- Не имеет свойств `super` и `new.target`
- Короткий и лаконичный синтаксис
- Автоматически возвращает результат выражения, если нет фигурных скобок
- Если принимает один параметр, скобки вокруг аргумента можно опустить
</details>

---

<details>
<summary><span>13. Что такое <b>замыкание</b>?</span></summary>
<br />

Замыкание - это механизм, который позволяет функции сохранять ссылку на свое лексическое окружение, даже если оно больше не существует в основном стеке вызовов

</details>

---

<details>
<summary><span>14. Для чего можно использовать замыкания?</span></summary>
<br />

- Сохранение состояния между вызовами функции

```javascript
function debounce(fn, delay) {
	let timerId;
	return (...args) => {
		clearTimeout(timerId);
		timerId = setTimeout(() => fn(...args), delay);
	};
}
```

- Инкапсуляция данных, скрытие переменных внутри замыкания и предотвращение их модификации извне

```javascript
function createCounter(initialValue = 0) {
	let count = initialValue; // приватное состояние

	return {
		increment() {
			count++;
		},
		decrement() {
			count--;
		},
		get() {
			return count;
		},
	};
}
```

- Использование функционального программирования, например, композиции функций

```javascript
const compose =
	(...funcs) =>
	input =>
		funcs.reduceRight((acc, fn) => fn(acc), input);
```

- Создание частично применяемых функций путём фиксации аргументов (каррирование)

```javascript
const add = a => b => a + b;
```

</details>

---

<details>
<summary><span>15. Что делает ключевое слово <b>this</b>?</span></summary>
<br />

Ключевое слово `this` в JavaScript ссылается на контекст выполнения функции, то есть объект, внутри которого была вызвана функция.

**Важно:**

- В обычной функции `this` определяется местом вызова функции (кто её вызвал).
- В стрелочной функции `this` определяется местом объявления функции и не изменяется, даже если функция вызывается в другом контексте.

Примеры использования `this`:

- **Метод объекта -** `this` ссылается на сам объект, в котором вызван метод.
- **Обычная функция (в строгом режиме) -** `this` не определён (`undefined`), так как функция вызвана вне контекста объекта.
- **Стрелочная функция -** `this` берёт значение из внешнего контекста, в котором функция была объявлена, а не вызвана.
- **Обработчик событий -** `this` ссылается на HTML-элемент, в котором произошло событие (например, кнопку).
- **Конструктор (new) -** `this` ссылается на вновь созданный объект.
- **Метод класса -** `this` ссылается на экземпляр класса, на котором был вызван метод.

</details>

---

<details>
<summary><span>16. Перечислите методы перебора массива в JavaScript?</span></summary>
<br />

- `map` – создаёт новый массив, применяя функцию к каждому элементу
- `forEach` – выполняет заданную функцию для каждого элемента массива
- `filter` – создаёт новый массив с элементами, удовлетворяющими заданному условию
- `reduce` – сводит массив к единому значению, применяя функцию к каждому элементу
- `some` – проверяет, соответствует ли хотя бы один элемент указанному условию
- `every` – проверяет, соответствуют ли все элементы указанному условию
- `find` – возвращает первый элемент, который удовлетворяет заданному условию
- `findIndex` – возвращает индекс первого элемента, удовлетворяющего условию
- `sort` – сортирует элементы массива по заданной функции сравнения
- `reverse` – изменяет порядок элементов массива на обратный
- `flatMap` – выполняет итерацию по элементам массива, применяет callback к каждому, создаёт новый массив из результатов и удаляет один уровень вложенности

</details>

---

<details>
<summary><span>17. Расскажите про <b>Event Loop</b>?</span></summary>
<br />

**Event Loop** — это механизм в JavaScript, который обеспечивает корректную последовательность выполнения задач.

Он состоит из трёх ключевых компонентов:

1. **Call Stack** – стек выполнения, в котором выполняется синхронный код (работает по принципу LIFO: последний вошёл — первый вышел).
2. **Callback Queue** – очередь макрозадач (таймеры, события и др.), функционирующая по принципу FIFO.
3. **Web APIs** – интерфейсы браузера или среды, обрабатывающие асинхронные операции (`setTimeout`, события и т. д.).

Один цикл **Event Loop** происходит следующим образом:

1. Выполняется весь синхронный код из **Call Stack**.
2. Обрабатываются все микрозадачи.
3. Выполняется одна макрозадача из **Callback Queue**.

Этот процесс повторяется, пока остаются незавершённые задачи.

**Event Loop** обеспечивает асинхронную природу JavaScript, позволяя выполнять операции с неопределённым временем завершения (например, запросы к серверу) без блокировки главного потока исполнения кода.

</details>

---

<details>
<summary><span>18. Какие задачи относятся к микрозадачам?</span></summary>
<br />

- **Promise** – методы `.then()`, `.catch()`, `.finally()`
- **queueMicrotask()** – явный вызов микрозадачи
- **MutationObserver** – отслеживание изменений в DOM

</details>

---

<details>
<summary><span>19. Какие наблюдатели существуют в JavaScript?</span></summary>
<br />

1. **MutationObserver** – отслеживает изменения в DOM
2. **IntersectionObserver** – отслеживает появление или исчезновение элемента в области видимости
3. **ResizeObserver** – отслеживает изменения размеров элемента
4. **PerformanceObserver** – анализирует события, связанные с производительностью

</details>

---

<details>
<summary><span>20. Какие способы работы с асинхронным кодом существуют?</span></summary>
<br />

1. **Callbacks** – базовый подход, который может привести к "адскому вложению колбэков"
2. **Promises** – более удобный способ управления асинхронными операциями
3. **async/await** – современный синтаксис для удобного управления асинхронным кодом

</details>

---

<details>
<summary><span>21. Что такое <b>async/await</b>?</span></summary>
<br />

Это синтаксис для работы с асинхронным кодом, позволяющий писать его так, как будто он синхронный, упрощая его чтение и обработку ошибок.

- **async** перед функцией означает, что она всегда возвращает Promise
- **await** заставляет JavaScript дождаться выполнения Promise перед продолжением кода

</details>

---

<details>
<summary><span>22. Что такое <b>Promise</b>?</span></summary>
<br />

**Promise** — это синтаксис для работы с асинхронным кодом.  
Название отражает его суть: промис — это объект, который гарантирует возврат результата операции в будущем.
</br></br>

Promise имеет **три состояния**:

1. **pending** – ожидание (начальное состояние)
2. **fulfilled** – успешно выполнен
3. **rejected** – завершён с ошибкой
   </br></br>

Промисы позволяют удобно строить **цепочки**:

- `.then()` – выполняется при успешном завершении (**fulfilled**)
- `.catch()` – обрабатывает ошибки (**rejected**)
- `.finally()` – выполняется независимо от результата
  </br></br>

`.then(resolve, reject)` – принимает два необязательных колбэка.

1. **первый** – функция, вызываемая при успешном выполнении (`resolve`)
2. **второй** – функция, вызываемая в случае ошибки (`reject`)

Но ошибки чаще обрабатываются отдельно через `.catch()`.
</br></br>

**Promise** также имеет статические методы:

- `Promise.all()` – ждёт выполнения всех промисов или отклонения одного
- `Promise.allSettled()` – ждёт завершения всех промисов независимо от результата
- `Promise.race()` – возвращает результат первого завершённого промиса (успех или ошибка)
- `Promise.any()` – возвращает первый **успешный** результат, игнорируя ошибки

</details>

---

<details>
<summary><span>23. Какие типы операторов существуют в JavaScript?</span></summary>
<br />

1. **Арифметические операторы**

   - `+` (сложение)
   - `-` (вычитание)
   - `*` (умножение)
   - `/` (деление)
   - `%` (остаток от деления)
   - `**` (возведение в степень)
   - `++` (инкремент)
   - `--` (декремент)

2. **Операторы присваивания**

   - `=` (простое присваивание)
   - `+=`, `-=`, `*=`, `/=`, `%=` (комбинированные операторы присваивания)
   - `**=` (присваивание степени)

3. **Операторы сравнения**

   - `==` (равенство без проверки типа)
   - `===` (строгое равенство с проверкой типа)
   - `!=` (неравенство)
   - `!==` (строгое неравенство)
   - `>` (больше)
   - `<` (меньше)
   - `>=` (больше или равно)
   - `<=` (меньше или равно)

4. **Логические операторы**

   - `&&` (логическое "и")
   - `||` (логическое "или")
   - `!` (логическое "не")

5. **Побитовые операторы**

   - `&` (побитовое "и")
   - `|` (побитовое "или")
   - `^` (побитовое "исключающее или")
   - `~` (побитовое "не")
   - `<<` (сдвиг влево)
   - `>>` (сдвиг вправо)
   - `>>>` (сдвиг вправо с заполнением нулями)

6. **Оператор типа**

   - `typeof` (возвращает строку, указывающую тип значения)

7. **Оператор объединения с null**

   - `??` (проверяет, равен ли левый операнд `null` или `undefined`. Если да, возвращает правый)

8. **Тернарный оператор**

   - `? :` (условный оператор)

9. **Строковые операторы**

   - `+` (конкатенация строк)
   - `+=` (добавление к строке)

10. **Другие операторы**

- `delete` (удаляет свойство объекта)
- `in` (проверяет существование свойства в объекте)
- `instanceof` (проверяет принадлежность объекта к определённому классу)
- `await` (используется внутри `async` функций для работы с промисами)
- `new` (создаёт экземпляр объекта)

</details>

---

<details>
<summary><span>24. Какой логический оператор имеет наивысший приоритет?</span></summary>
<br />

Оператор `!` (логическое "НЕ") обладает наивысшим приоритетом среди логических операторов в JavaScript.

</details>

---

<details>
<summary><span>25. В чём разница между <b>==</b> и <b>===</b>?</span></summary>
<br />

1. `==`

- Сравнивает два значения без учёта их типа
- Автоматически преобразует типы данных при необходимости
- Может приводить к неожиданным результатам из-за неявного приведения типов  
  <br /><br />

2. `===`

- Сравнивает как значение, так и тип без преобразования
- Возвращает `true`, только если оба операнда имеют одинаковый тип и значение
- Предотвращает ошибки, связанные с неявными преобразованиями типов

</details>

---

<details>
<summary><span>26. Как работают постфиксные и префиксные операторы инкремента и декремента?</span></summary>
<br />

- **Префиксный инкремент (`++variable`) и декремент (`--variable`)**  
  Сначала увеличивают/уменьшают значение переменной, затем возвращают обновлённое значение.

- **Постфиксный инкремент (`variable++`) и декремент (`variable--`)**  
  Сначала возвращают старое значение, затем увеличивают/уменьшают переменную.

</details>

---

<details>
<summary><span>27. Что такое <b>короткое замыкание</b> в JavaScript?</span></summary>
<br />

Это особенность логических операторов `&&` и `||`, при которой выражение **прекращает выполнение** сразу, как только становится известен его результат.

```js
let x = a || (b && c);
```

Если `a` имеет **true**-значение, выражение **завершается** на `a`, а `b && c` **не вычисляется**.

Этот механизм помогает **оптимизировать код** и **избежать лишних вычислений**, особенно в условиях `if` или сложных логических выражениях.

</details>

---

<details>
<summary><span>28. Что делает оператор <b>instanceof</b>?</span></summary>
<br />

Используется для проверки, принадлежит ли объект определённому конструктору или классу.

```javascript
class Animal {}
let dog = new Animal();

console.log(dog instanceof Animal); // true (dog создан через Animal)
console.log(dog instanceof Object); // true (все объекты наследуются от Object)
console.log(dog instanceof Array); // false (dog — не массив)
```

</details>

---

<details>
<summary><span>29. Какой оператор можно использовать для проверки существования свойства в объекте?</span></summary>
<br />

Оператор `in` проверяет наличие свойства в объекте, включая унаследованные свойства из его прототипа.

```javascript
let obj = { name: 'Alice' };

console.log('name' in obj); // true (свойство существует)
console.log('toString' in obj); // true (унаследовано от Object.prototype)
```

</details>

---

<details>
<summary><span>30. Как проверить, является ли свойство собственным, а не унаследованным?</span></summary>
<br />

Метод `hasOwnProperty()` позволяет проверить, является ли свойство собственным, исключая унаследованные свойства.

```javascript
console.log(obj.hasOwnProperty('name')); // true (собственное свойство)
console.log(obj.hasOwnProperty('toString')); // false (унаследовано)
```

</details>

---

<details>
<summary><span>31. Что такое <b>IIFE</b>?</span></summary>
<br />

**Immediately Invoked Function Expression (IIFE)** — это функция, которая выполняется сразу после объявления. Она часто используется для создания локальной области видимости и предотвращения конфликтов имён.

Примеры **IIFE**:

```javascript
// Стандартный синтаксис
(function () {
	console.log('IIFE выполнена!');
})();

// Стрелочная функция
(() => {
	console.log('Стрелочная IIFE');
})();

// Передача параметра
(name => {
	console.log(`Привет, ${name}!`);
})('Алекс');
```

</details>

---

<details>
<summary><span>32. Как работает <b>сборщик мусора</b>?</span></summary>
<br />

Сборщик мусора работает на основе концепции **доступности объектов**.  
Объект считается доступным, если до него можно добраться по цепочке ссылок, начиная с так называемых **корневых объектов** — например, глобальных (`window`, `globalThis`), локальных переменных текущих функций, параметров, переменных в замыканиях и др.

Если объект доступен, он остаётся в памяти. Если нет, он становится недоступным и может быть удалён.

Наиболее распространённый алгоритм в JavaScript называется **"Mark-and-Sweep"**:

- **Маркировка (Mark):** Сборщик мусора проходит по всем доступным объектам от корневых и отмечает их.
- **Удаление (Sweep):** Все неотмеченные объекты считаются недоступными и удаляются.

</details>

---

<details>
<summary><span>33. <b>Map</b> и <b>Set</b> в JavaScript?</span></summary>
<br />

### **Map** – коллекция пар ключ-значение

- Ключи могут быть **любого типа** (в отличие от обычных объектов, где ключи — только строки или символы).
- **Сохраняет порядок вставки**.
- **Более оптимизирован для удаления свойств** по сравнению с обычными объектами.
  <br /><br />

**Основные методы:**
| Метод | Описание |
|--------|------------|
| `map.set(key, value)` | Устанавливает значение по ключу |
| `map.get(key)` | Получает значение по ключу |
| `map.has(key)` | Проверяет наличие ключа |
| `map.delete(key)` | Удаляет запись по ключу |
| `map.clear()` | Очищает всю коллекцию |
| `map.size` | Возвращает количество элементов |
<br />

### **Set** – коллекция уникальных значений

- **Значения не повторяются**.
- **Сохраняет порядок вставки**.
- **Позволяет быстро проверять наличие элемента**.
  <br /><br />

**Основные методы:**
| Метод | Описание |
|--------|------------|
| `set.add(value)` | Добавляет значение |
| `set.has(value)` | Проверяет наличие значения |
| `set.delete(value)` | Удаляет значение |
| `set.clear()` | Очищает коллекцию |
| `set.size` | Возвращает количество уникальных значений |

</details>

---

<details>
<summary><span>34. <b>WeakMap</b> и <b>WeakSet</b> в JavaScript?</span></summary>
<br />

**WeakMap** и **WeakSet** — это ослабленные версии `Map` и `Set`, предназначенные для работы с временными данными. Они отличаются управлением памятью и поведением при сборке мусора.

### **WeakMap** – коллекция пар ключ-значение с особыми свойствами:

- **Ключами могут быть только объекты** (строки, числа и другие примитивы не допускаются).
- **Не мешает сборке мусора** — если объект больше не используется, он автоматически удаляется.
- **Нет методов `.size`, `.keys()`, `.values()`, `.entries()`** — итерация по данным невозможна.
  <br /><br />

✅ **Основные методы:**
| Метод | Описание |
|--------|------------|
| `weakMap.set(obj, value)` | Добавляет пару ключ-значение (`объект → значение`) |
| `weakMap.get(obj)` | Получает значение по объекту |
| `weakMap.has(obj)` | Проверяет наличие объекта в коллекции |
| `weakMap.delete(obj)` | Удаляет объект из коллекции |
<br />

🔹 **Применение** – хранение данных, которые должны автоматически удаляться, например, кэширование или привязка метаданных к объектам.

```js
const weakMap = new WeakMap();
let user = { name: 'Антон' };

weakMap.set(user, 'данные');
console.log(weakMap.get(user)); // 'данные'

user = null; // Теперь объект может быть удалён сборщиком мусора.
```

<br />

### **WeakSet** – коллекция **уникальных объектов**:

- **Может содержать только объекты** (примитивные значения не допускаются).
- **Объекты автоматически удаляются**, если больше не используются.
- **Нет метода `.size` или возможности итерации**.
  <br /><br />

✅ **Основные методы:**
| Метод | Описание |
|--------|------------|
| `weakSet.add(obj)` | Добавляет объект |
| `weakSet.has(obj)` | Проверяет наличие объекта |
| `weakSet.delete(obj)` | Удаляет объект |
<br />

🔹 **Применение** – отслеживание объектов без риска утечек памяти, например, временные метки для операций.

```js
const weakSet = new WeakSet();
let session = { id: 123 };

weakSet.add(session);
console.log(weakSet.has(session)); // true

session = null; // Теперь объект может быть удалён сборщиком мусора.
```

WeakMap и WeakSet полезны, когда объекты должны **исчезать из коллекции** при потере ссылок, помогая предотвратить **утечки памяти**.

</details>

---

<details>
<summary><span>35. Почему коллекция <b>Map</b> более оптимизирована для удаления полей, чем обычный объект?</span></summary>
<br />

Обычные объекты изначально оптимизированы для **статической структуры**, когда набор ключей не меняется. Это позволяет движку V8 (в Chrome и Node.js) и другим движкам использовать **скрытые классы** и **inline-кэширование** для ускорения доступа к свойствам.
<br /><br />

Когда используется `delete obj.key`, происходит **разрушение оптимизации**, связанной с этими скрытыми классами:

- Скрытый класс изменяется.
- Доступ к свойствам становится медленнее.
- Объект перестаёт быть "простым", что снижает производительность.
  <br /><br />

С `Map` ситуация другая:

- `Map` **создан** для частых изменений и операций с ключами, включая удаление.
- Удаление ключей в `Map` **не вызывает деоптимизации** в движке JavaScript.
- `Map` **не имеет цепочки прототипов**, поэтому нет конфликтов с унаследованными свойствами.
- В `Map` **удаление работает надёжно и эффективно**, даже при больших объёмах данных.

</details>

---

<details>
<summary><span>36. Что делает ключевое слово <b>new</b>?</span></summary>
<br />

Ключевое слово `new` в основном используется для создания экземпляра объекта на основе функции-конструктора или класса.

Вот основные случаи использования `new` в JavaScript:

1. **Создание объектов с помощью конструктора** – Позволяет создавать экземпляры объектов:

   ```javascript
   function Person(name) {
   	this.name = name;
   }
   const user = new Person('Антон');
   ```

2. **Создание встроенных типов объектов** – Генерирует объекты-обёртки:

   ```javascript
   const num = new Number(42); // объект, а не примитивное число
   const str = new String('Привет'); // объект-обёртка для строки
   const bool = new Boolean(true); // объект-обёртка для логического значения
   ```

3. **Создание экземпляров классов** – Используется для создания объектов через `class`:

   ```javascript
   class Car {
   	constructor(model) {
   		this.model = model;
   	}
   }
   const myCar = new Car('Tesla');
   ```

4. **Работа с `Map`, `Set` и `WeakMap`** – Создание коллекций:

   ```javascript
   const map = new Map();
   const set = new Set();
   const weakMap = new WeakMap();
   ```

5. **Создание объектов `Date`** – Позволяет работать с датами:

   ```javascript
   const now = new Date();
   ```

6. **Использование `RegExp` для регулярных выражений** – Создание динамических паттернов:

   ```javascript
   const regex = new RegExp('\\d+');
   console.log(regex.test('123')); // true
   ```

7. **Работа с `Promise`** – Создание нового промиса:

   ```javascript
   const myPromise = new Promise(resolve => resolve('Готово!'));
   myPromise.then(console.log); // "Готово!"
   ```

8. **Создание объектов `Error`** – Используется для обработки ошибок:
   ```javascript
   const err = new Error('Что-то пошло не так!');
   console.error(err.message);
   ```

</details>

---

<details>
<summary><span>37. Что такое прототипное наследование?</span></summary>
<br />

Это механизм в JavaScript, позволяющий объектам наследовать свойства и методы от других объектов.

Каждый объект в JavaScript имеет скрытое свойство `[[Prototype]]`, которое указывает на другой объект (его прототип). Если запрашивается свойство, которого нет в текущем объекте, JavaScript ищет его в прототипе.

</details>

---

<details>
<summary><span>38. Как создать объект с заданным прототипом?</span></summary>
<br />

В JavaScript объект можно создать с определённым прототипом несколькими способами:

### 1. `Object.create(prototype)`

Это наиболее удобный способ создания объекта с заданным прототипом:

```javascript
const person = {
	greet() {
		console.log('Привет!');
	},
};

const user = Object.create(person);
user.name = 'Антон';

console.log(user.name); // "Антон"
user.greet(); // "Привет!" (унаследовано от person)
```

### 2. Использование `__proto__`

Можно явно задать прототип с помощью `__proto__`, но этот метод плохо оптимизирован, устарел и **не рекомендуется**:

```javascript
const person = {
	greet() {
		console.log('Привет!');
	},
};

const user = { name: 'Антон' };
user.__proto__ = person;

user.greet(); // "Привет!"
```

### 3. `Object.setPrototypeOf(obj, prototype)`

Безопасный способ изменить прототип объекта после его создания:

```javascript
const person = {
	greet() {
		console.log('Привет!');
	},
};

const user = { name: 'Антон' };
Object.setPrototypeOf(user, person);

user.greet(); // "Привет!"
```

### 4. Использование функции-конструктора и `prototype`

Этот метод часто используется для создания нескольких экземпляров:

```javascript
function Person(name) {
	this.name = name;
}

Person.prototype.greet = function () {
	console.log(`Привет, меня зовут ${this.name}`);
};

const user = new Person('Антон');
user.greet(); // "Привет, меня зовут Антон"
```

</details>

---

<details>
<summary><span>39. Как изменить прототип объекта после его создания?</span></summary>
<br />

Это можно сделать следующими способами:

- `Object.setPrototypeOf()`
- `__proto__` (не рекомендуется)

</details>

---

<details>
<summary><span>40. Как проверить, является ли объект прототипом другого объекта?</span></summary>
<br />

- **`Object.prototype.isPrototypeOf(obj)`**

  ```javascript
  const person = {};
  const user = Object.create(person);

  console.log(person.isPrototypeOf(user)); // true
  ```

- **`Object.getPrototypeOf()`** – этот метод возвращает прототип объекта, который можно сравнить напрямую

  ```javascript
  const person = {};
  const user = Object.create(person);

  console.log(Object.getPrototypeOf(user) === person); // true
  ```

- **`__proto__` (не рекомендуется)**

  ```javascript
  const person = {};
  const user = {};
  user.__proto__ = person;

  console.log(user.__proto__ === person); // true
  ```

</details>

---

<details>
<summary><span>41. Что произойдёт, если свойство не найдено в объекте или его прототипе?</span></summary>
<br />

Если свойство не найдено в объекте или его прототипе, JavaScript вернёт `undefined`.

</details>

---

<details>
<summary><span>42. В чём разница между <b>__proto__</b> и <b>prototype</b>?</span></summary>
<br />

### **`__proto__` (устарело, но используется)**

Свойство экземпляра объекта, которое указывает на его прототип. Позволяет получить или изменить прототип, но **не рекомендуется** из-за проблем с производительностью.

#### **Пример:**

```javascript
const person = {
	greet() {
		console.log('Привет!');
	},
};
const user = { name: 'Антон' };
user.__proto__ = person; // Изменение прототипа

console.log(user.greet()); // "Привет!" (унаследовано)
```

---

### **`prototype` (используется в конструкторах и классах)**

Свойство конструктора или класса, определяющее прототип для всех создаваемых объектов через `new`. Позволяет добавлять методы, которые будут общими для всех экземпляров.

#### **Пример:**

```javascript
function Person(name) {
	this.name = name;
}

Person.prototype.sayHello = function () {
	console.log(`Привет, меня зовут ${this.name}`);
};

const user = new Person('Антон');
user.sayHello(); // "Привет, меня зовут Антон"
```

</details>

---

<details>
<summary><span>43. Как удалить связь объекта с его прототипом?</span></summary>
<br />

- `Object.setPrototypeOf(obj, null)` – удаляет прототип у существующего объекта.
- `Object.create(null)` – создаёт объект без прототипа.

</details>

---

<details>
<summary><span>44. Для чего используются <b>шаблонные литералы</b>?</span></summary>
<br />

Это удобный способ создания строк, позволяющий встроить переменные и выражения прямо в текст.

</details>

---

<details>
<summary><span>45. Какие значения в JavaScript считаются ложными?</span></summary>
<br />

- `false` — логическое `false`.
- `0`, `-0`, `0n` — все варианты нуля, включая `BigInt 0n`.
- `""`, `''`, ```` — пустые строки.
- `null` — отсутствие значения.
- `undefined` — неопределённое значение.
- `NaN` — "Не число", результат некорректных математических операций.

</details>

---

<details>
<summary><span>46. Что такое <b>деструктуризация</b>?</span></summary>
<br />

**Деструктуризация** — это удобный способ извлечения значений из объектов и массивов и их присваивания переменным в JavaScript.

### **Примеры:**

- **Объекты:**
  ```js
  const user = { name: 'Антон', age: 33 };
  const { name, age } = user;
  console.log(name, age); // "Антон", 33
  ```
- **Массивы:**
  ```js
  const numbers = [10, 20, 30];
  const [first, second] = numbers;
  console.log(first, second); // 10, 20
  ```

</details>

---

<details>
<summary><span>47. Что такое <b>чистая функция</b>?</span></summary>
<br />

**Чистая функция** — это функция, которая всегда возвращает один и тот же результат при одинаковых входных данных и не изменяет внешнее состояние.

</details>

---

<details>
<summary><span>48. Что такое <b>функция высшего порядка</b>?</span></summary>
<br />

Функция высшего порядка — это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как результат.

</details>

---

<details>
<summary><span>49. Как проверить, является ли значение массивом?</span></summary>
<br />

1. `Array.isArray()`

   ```js
   console.log(Array.isArray([1, 2, 3])); // true
   console.log(Array.isArray({ a: 1, b: 2 })); // false
   ```

2. `Object.prototype.toString.call(value)`
   ```js
   console.log(Object.prototype.toString.call([1, 2, 3])); // "[object Array]"
   ```

</details>

---

<details>
<summary><span>50. Как проверить, является ли значение объектом?</span></summary>
<br />

`Object.prototype.toString.call(value)`

```js
console.log(Object.prototype.toString.call({ a: 1 })); // "[object Object]"
```

</details>

---

<details>
<summary><span>51. Какие методы объектов существуют?</span></summary>
<br />

### **Работа с ключами и значениями**

- `Object.keys(obj)` — возвращает массив ключей объекта.
- `Object.values(obj)` — возвращает массив значений.
- `Object.entries(obj)` — возвращает массив пар `[ключ, значение]`.

### **Работа со свойствами**

- `Object.assign(target, source)` — копирует свойства из одного объекта в другой.
- `Object.defineProperty(obj, key, descriptor)` — определяет новое свойство с настройками (`writable`, `configurable`, `enumerable`).
- `Object.defineProperties(obj, descriptors)` — аналог `defineProperty`, но для нескольких свойств.

### **Проверки и прототипы**

- `Object.hasOwn(obj, key)` — проверяет, есть ли ключ в объекте **(без учёта прототипа)**.
- `Object.prototype.hasOwnProperty(key)` — проверяет наличие конкретного свойства в объекте.
- `Object.getPrototypeOf(obj)` — возвращает прототип объекта.
- `Object.setPrototypeOf(obj, prototype)` — изменяет прототип объекта.

### **Создание и заморозка объектов**

- `Object.create(proto)` — создаёт новый объект с указанным прототипом.
- `Object.freeze(obj)` — делает объект **неизменяемым** (нельзя добавлять или удалять свойства).
- `Object.seal(obj)` — запрещает удаление свойств, но позволяет их изменять.

</details>

---

<details>
<summary><span>52. Как привязать функцию к контексту?</span></summary>
<br />

- **call** – вызывает функцию с указанным контекстом и передаёт аргументы по отдельности.
- **apply** – аналогично `call`, но аргументы передаются массивом.
- **bind** – создаёт новую функцию с привязанным контекстом, но не вызывает её сразу.
- **стрелочные функции** – автоматически привязывают `this` к окружающему контексту, где они объявлены.

</details>

---

<details>
<summary><span>53. Что делает оператор <b>Spread</b>?</span></summary>
<br />

Оператор Spread используется для копирования или объединения массивов и объектов.

Примеры:

✅ **Объединение массивов**:

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]
```

✅ **Копирование объекта**:

```javascript
const person = { name: 'Алиса', age: 25 };
const copiedPerson = { ...person };

console.log(copiedPerson); // { name: 'Алиса', age: 25 }
```

</details>

---

<details>
<summary><span>54. Что делает оператор <b>Rest</b>?</span></summary>
<br />

Оператор Rest используется для сбора переданных в функцию аргументов в массив, чтобы их можно было удобно обработать.

Эта техника полезна, когда **количество параметров заранее неизвестно**, но их всё же нужно обработать.

### ✅ Пример:

```javascript
function logArguments(first, second, ...rest) {
	console.log(`Первый: ${first}`);
	console.log(`Второй: ${second}`);
	console.log(`Остальные:`, rest);
}

logArguments(1, 2, 3, 4, 5);
// Первый: 1
// Второй: 2
// Остальные: [3, 4, 5]
```

</details>

---

<details>
<summary><span>55. Что такое <b>всплытие событий (event bubbling)</b>?</span></summary>
<br />

**Всплытие событий** — это процесс, при котором событие, произошедшее на вложенном элементе, сначала обрабатывается на этом элементе, а затем поднимается вверх по иерархии DOM, вызывая обработчики событий на родительских элементах.

Это происходит потому, что вложенные элементы являются частью их родительских контейнеров, и взаимодействие с ними затрагивает всю цепочку вложенности вплоть до корневого элемента.

</details>

---

<details>
<summary><span>56. Что такое <b>перехват событий (event capturing)</b>?</span></summary>
<br />

**Перехват событий** — это этап обработки событий, противоположный всплытию. На этом этапе событие начинает распространяться сверху вниз — от корневого элемента DOM-дерева к целевому элементу.

По умолчанию перехват событий отключён. Чтобы его включить, нужно передать `true` как третий аргумент в `addEventListener` или использовать объект `{ capture: true }`.

```javascript
element.addEventListener('click', handler, true);

element.addEventListener('click', handler, { capture: true });
```

</details>

---

<details>
<summary><span>57. Как остановить всплытие событий?</span></summary>
<br />

Чтобы остановить всплытие события, вызовите метод `event.stopPropagation()` внутри обработчика события дочернего элемента в `addEventListener`.

</details>

---

<details>
<summary><span>58. Что такое <b>Shadow Dom</b>?</span></summary>
<br />

Shadow DOM - это технология веб-компонентов, которая позволяет создавать изолированное DOM-дерево, присоединенное к элементу, но отдельное от основного DOM документа. Это обеспечивает инкапсуляцию стилей и разметки компонента.

</details>

---

<details>
<summary><span>59. Почему мы можем вызывать методы у примитивов?</span></summary>
<br />

Когда мы пытаемся вызвать метод у примитива, JavaScript автоматически оборачивает его во временный объект-обертку (wrapper object).

Этот процесс называется "автоупаковкой" (autoboxing). После вызова метода временный объект удаляется.

</details>

---

<details>
<summary><span>60. Как скопировать объект?</span></summary>
<br />

### **Методы поверхностного копирования**:

- `Object.assign()`
- `spread` operator (`...`)
- `Array.prototype.slice()` (для массивов)
- `Array.prototype.concat()` (для массивов)
- `Object.create()`

### **Методы глубокого копирования**:

- `structuredClone()`
- `JSON.parse(JSON.stringify(obj))`
- Рекурсивный обход
- `lodash.cloneDeep()`
- `cloneDeep` из `underscore.js`

</details>

---

<!--
Какой тип данных возвращает reduce?
Сколько потоков в JS?
RequestAnimationFrame
Генераторы
Что такое псевдомассив?
Зачем нужны регулярные выражения?
Как ограничить жадность регулярного выражения?
Что такое символьный класс в регуярках?
Якорные символы в регулярках?
Флаги в регулярных выражениях
Методы регулярных выражений?
Карманы в регулярках?
Все ли объекты в джс имеют прототипы? Object.create(null)
 -->

<!--
<details>
<summary><span></span></summary>
<br />

</details>

--- -->
