<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/protocol.png">
  <h2>Протоколы</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>HTTP</b>?</span></summary>
<br />

Это протокол передачи данных, используемый для обмена информацией между клиентом (обычно браузером) и сервером в интернете. Он работает по модели запрос–ответ: клиент отправляет запрос, а сервер возвращает ответ.

</details>

---

<details>
<summary><span>2. Чем отличаются протоколы <b>HTTP</b> и <b>HTTPS</b>?</span></summary>
<br />

<b>HTTPS</b> — это защищённая версия HTTP. Она использует шифрование с помощью TLS (ранее SSL), чтобы данные передавались безопасно: их нельзя перехватить или подделать. Такой протокол особенно важен при передаче логинов, паролей и другой чувствительной информации.

</details>

---

<details>
<summary><span>3. Какова <b>структура HTTP-запроса</b>?</span></summary>
<br />

Структура HTTP-запроса включает три основные части:

1. <b>Стартовая строка (Request Line)</b> — указывает метод запроса (например, `GET`, `POST`), путь к ресурсу и версию протокола, например:  
   `GET /index.html HTTP/1.1`

2. <b>Заголовки (Headers)</b> — ключ-значение параметры, которые передают дополнительную информацию, например:  
   &nbsp;&nbsp;`Host: example.com`  
   &nbsp;&nbsp;`User-Agent: Mozilla/5.0`

3. <b>Тело (Body)</b> — используется в основном в `POST`, `PUT` и других методах для отправки данных, например JSON, форм или файлов.
   <br /><br />

Пример:

```
GET /about HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html
```

</details>

---

<details>
<summary><span>4. Какие <b>заголовки HTTP-запроса</b> вы знаете и зачем они нужны?</span></summary>
<br />

Вот список распространённых заголовков HTTP-запроса с кратким описанием:

- **`Host`** — указывает доменное имя сервера, к которому отправляется запрос (обязателен в HTTP/1.1).  
  Пример: `Host: example.com`

- **`User-Agent`** — сообщает информацию о клиенте (браузер, ОС и т. д.), отправляющем запрос
  Пример: `User-Agent: Mozilla/5.0`

- **`Accept`** — определяет, какие типы контента клиент может обработать
  Пример: `Accept: text/html, application/json`

- **`Content-Type`** — описывает тип данных в теле запроса (важно для POST/PUT)
  Пример: `Content-Type: application/json`

- **`Authorization`** — передаёт учётные данные (токен или базовую авторизацию) для доступа к защищённым ресурсам
  Пример: `Authorization: Bearer <token>`

- **`Accept-Encoding`** — указывает, какие методы сжатия данных поддерживает клиент
  Пример: `Accept-Encoding: gzip, deflate`

- **`Referer`** — сообщает, с какого URL пользователь перешёл на текущий ресурс
  Пример: `Referer: https://google.com`

- **`Cookie`** — отправляет сохранённые на клиенте cookies
  Пример: `Cookie: sessionId=abc123`

- **`Cache-Control`** — управляет кэшированием запроса
  Пример: `Cache-Control: no-cache`

- **`Connection`** — управляет параметрами соединения, например `keep-alive` или `close`

</details>

---

<details>
<summary><span>5. Что может содержать в <b>тело HTTP - запроса</b>?</span></summary>
<br />

Тело HTTP-сообщения (body) может содержать самые разные данные, в зависимости от типа запроса или ответа. Вот что обычно встречается:

- **Форматированные данные форм** — например, `application/x-www-form-urlencoded` или `multipart/form-data` при загрузке файлов
- **JSON** — популярный формат для API-запросов и ответов.
  Пример: `{ "name": "Anton", "role": "developer" }`
- **XML** — используется в некоторых старых API или специфичных системах
- **Текст** — обычный текст, HTML или markdown
- **Бинарные данные** — изображения, видео, аудиофайлы и т. д.
- **Пустое тело** — например, у `GET` и `DELETE` запросов тело часто отсутствует

Тип содержимого указывается в заголовке `Content-Type`, чтобы принимающая сторона знала, как его интерпретировать.

</details>

---

<details>
<summary><span>6. Какие <b>методы HTTP-запросов</b> вы знаете?</span></summary>
<br />

Вот список распространённых методов HTTP-запросов и их краткое описание:

- **`GET`** — запрашивает данные с сервера
- **`POST`** — отправляет данные на сервер
- **`PUT`** — полностью заменяет существующий ресурс заданными данными
- **`PATCH`** — частично обновляет ресурс
- **`DELETE`** — удаляет указанный ресурс
- **`HEAD`** — как `GET`, но без тела, получает только заголовки
- **`OPTIONS`** — запрашивает у сервера, какие методы и параметры поддерживаются для конкретного ресурса
- **`CONNECT`** — устанавливает туннель к серверу, обычно используется для HTTPS-прокси
- **`TRACE`** — возвращает полученный запрос для диагностики (встречается редко, часто отключён по соображениям безопасности)

</details>

---

<details>
<summary><span>7. Для чего нужен <b>HEAD</b>?</span></summary>
<br />

Метод `HEAD` выполняет такой же запрос, как `GET`, но без тела ответа — сервер возвращает только заголовки. Это позволяет:

- Проверить существование ресурса без загрузки содержимого.
- Узнать размер файла (`Content-Length`) перед скачиванием.
- Проверить, изменился ли ресурс (с помощью заголовка `Last-Modified` или `ETag`).
- Использовать его для отладки, мониторинга и экономии трафика.

</details>

---

<details>
<summary><span>8. Для чего нужен <b>OPTIONS</b>?</span></summary>
<br />

Метод `OPTIONS` используется для запроса у сервера информации о доступных HTTP-методах и других возможностях для указанного ресурса. Особенно важен в контексте CORS (междоменных запросов), где помогает определить, разрешён ли запрос и какие заголовки/методы допустимы.

Применения:

- Узнать, какие методы (`GET`, `POST`, `PUT` и т. д.) поддерживает сервер для конкретного ресурса.
- Проверить допустимые заголовки и источники при кросс-доменных запросах.
- Используется браузером для **preflight-запросов** в CORS, чтобы не выполнять опасные запросы без разрешения.

</details>

---

<details>
<summary><span>9. Что такое <b>preflight-запрос</b>?</span></summary>
<br />

**Preflight-запрос** — это предварительный запрос, который браузер автоматически отправляет с помощью метода `OPTIONS` перед выполнением основного (например, `POST`, `PUT`) при междоменных запросах (CORS).

Цель — узнать, разрешает ли сервер такие запросы и какие заголовки/методы допустимы.

Пример: если сайт `example.com` хочет отправить `POST`-запрос на `api.another-site.com` с нестандартными заголовками или JSON-телом, браузер сначала выполнит `OPTIONS`-запрос, чтобы получить подтверждение.

</details>

---

<details>
<summary><span>10. Что такое <b>идемпотентность</b>?</span></summary>
<br />

Это свойство HTTP-метода, при котором повторное выполнение одного и того же запроса не изменяет состояние сервера после первого вызова

</details>

---

<details>
<summary><span>11. Какие методы HTTP-запросов идемпотентны?</span></summary>
<br />

- `GET`
- `PUT`
- `DELETE`
- `HEAD`
- `OPTIONS`
- `TRACE`

</details>

---

<details>
<summary><span>12. Какие <b>статус-коды</b> запросов вы знаете?</span></summary>
<br />

HTTP-статус-коды делятся на 5 основных групп по первой цифре кода:

### 1xx — **Информационные**

- `100 Continue` — сервер получил начальные заголовки, клиент может отправлять тело запроса
- `101 Switching Protocols` — клиент запросил смену протокола (например, на WebSocket), сервер согласен

### 2xx — **Успешные**

- `200 OK` — стандартный успешный ответ
- `201 Created` — успешно создан новый ресурс (например, при `POST`)

### 3xx — **Перенаправления**

- `301 Moved Permanently` — запрашиваемый ресурс навсегда перемещён по новому URL
- `302 Found` — временное перенаправление (часто используется при аутентификации)

### 4xx — **Ошибки клиента**

- `400 Bad Request` — некорректный запрос (например, синтаксическая ошибка).
- `404 Not Found` — ресурс не найден по указанному пути

### 5xx — **Ошибки сервера**

- `500 Internal Server Error` — внутренняя ошибка на сервере
- `502 Bad Gateway` — сервер получил некорректный ответ от вышестоящего сервера

</details>

---

<details>
<summary><span>13. Чем отличаются версии протокола <b>HTTP/1, HTTP/2 и HTTP/3</b>?</span></summary>
<br />

| Характеристика              | HTTP/1.1                             | HTTP/2                                | HTTP/3                                          |
| --------------------------- | ------------------------------------ | ------------------------------------- | ----------------------------------------------- |
| **Протокол транспорта**     | TCP                                  | TCP                                   | **QUIC** поверх UDP                             |
| **Мультиплексирование**     | ✘ (только один запрос за соединение) | ✔ (много запросов в одном соединении) | ✔ (ещё эффективнее и без head-of-line blocking) |
| **Сжатие заголовков**       | ✘                                    | ✔ (HPACK)                             | ✔ (QPACK)                                       |
| **Поддержка push**          | ✘                                    | ✔ (Server Push)                       | ✔ (но с ограниченным применением)               |
| **Устойчивость к потерям**  | ❌ Потеря пакета блокирует остальные | ❌ Может блокировать потоки из-за TCP | ✔ Потоки независимы, быстрая реакция на потери  |
| **Шифрование по умолчанию** | ✘ (необязательно, HTTPS поверх TLS)  | ✘                                     | ✔ (всегда шифрован, как TLS 1.3)                |
| **Статус распространения**  | Очень широко                         | Широко используется                   | Всё активнее внедряется                         |

</details>

---

<details>
<summary><span>14. Что такое <b>Host</b>-заголовок и почему он обязателен в HTTP/1.1?</span></summary>
<br />

Заголовок `Host` указывает доменное имя (и, при необходимости, порт) сервера, к которому направляется запрос.  
Пример: `Host: example.com`

Он обязателен в HTTP/1.1, потому что на одном IP-адресе может размещаться несколько сайтов (виртуальный хостинг), и серверу нужно знать, к какому именно из них обращается клиент.

Без `Host` сервер не сможет корректно обработать запрос, особенно если обслуживает несколько доменов.

</details>

---

<details>
<summary><span>15. Расскажите про <b>MIME</b>-тип</span></summary>
<br />

**MIME-тип** (Multipurpose Internet Mail Extensions) — это обозначение формата передаваемых данных в интернете. Он указывается в заголовке `Content-Type` и сообщает получателю, как интерпретировать тело сообщения.

Формат MIME-типа: `тип/подтип`, например:

- `text/html` — HTML-документ
- `application/json` — JSON-данные
- `image/png` — изображение в формате PNG
- `multipart/form-data` — форма с файлами (например, при загрузке изображений)
- `text/plain` — обычный текст

</details>

---

<details>
<summary><span>16. Что такое <b>User-Agent</b>?</span></summary>
<br />

**User-Agent** — это заголовок HTTP-запроса, который сообщает серверу сведения о клиенте: тип браузера, операционную систему, версию, устройство и др.

Пример:  
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/125.0.0.0`

Сервер может использовать эту информацию для адаптации контента, логирования или аналитики.

</details>

---

<details>
<summary><span>17. Что такое <b>Content-Type</b>?</span></summary>
<br />

**`Content-Type`** - это заголовок, который указывает формат тела запроса или ответа.

Пример: `Content-Type: application/json` означает, что отправляется JSON-данные.

</details>

---

<details>
<summary><span>18. Что такое <b>Accept</b>?</span></summary>
<br />

**`Accept`** — это заголовок, который сообщает серверу, какие форматы данных клиент готов принять в ответ.

Пример: `Accept: text/html, application/json` — клиент готов получить HTML или JSON.

</details>

---

<details>
<summary><span>19. Как работает <b>HTTP-кэш</b>? Расскажите про <b>Cache-Control</b>, <b>ETag</b>, <b>Last-Modified</b></span></summary>
<br />

HTTP-кэш позволяет браузеру повторно использовать уже загруженные ресурсы. Это ускоряет загрузку страниц и уменьшает нагрузку на сервер. Вот основные инструменты:
<br /><br />

### `Cache-Control` — управление стратегией кэширования

Указывает, можно ли кэшировать ресурс и на сколько:

- `no-cache` — не использовать кэш без проверки с сервером
- `max-age=3600` — кэшировать ресурс на 3600 секунд (1 час)  
  <br /><br />

### `ETag` — уникальный идентификатор ресурса

Сервер возвращает `ETag`, браузер его сохраняет. При следующем запросе браузер отправляет:

```
If-None-Match: <etag>
```

Если ресурс не изменился — получаем `304 Not Modified`, и браузер использует кэш.
<br /><br />

### `Last-Modified` — дата последнего обновления

Сервер указывает время последнего изменения. Браузер позже отправляет:

```
If-Modified-Since: <дата>
```

Если изменений не было — снова `304`.
<br /><br />

Эти механизмы **работают вместе**:

- `Cache-Control` управляет поведением кэша
- `ETag` и `Last-Modified` проверяют, актуальны ли данные

</details>

---

<details>
<summary><span>19. Что такое <b>WebSocket</b>?</span></summary>
<br />

**WebSocket** — это сетевой протокол, который позволяет установить постоянное, двустороннее соединение между клиентом и сервером.

</details>

---

<details>
<summary><span>20. Чем <b>WebSocket</b> отличается от <b>HTTP</b>?</span></summary>
<br />

Вот таблица с основными отличиями между HTTP и WebSocket:

| Характеристика              | **HTTP**                                    | **WebSocket**                                      |
| --------------------------- | ------------------------------------------- | -------------------------------------------------- |
| **Модель общения**          | Запрос → ответ                              | Постоянное двустороннее соединение                 |
| **Устойчивость соединения** | Закрывается после ответа                    | Остаётся открытым до явного закрытия               |
| **Направление связи**       | Только клиент инициирует                    | Оба могут отправлять данные в любое время          |
| **Надстройка над**          | TCP (через HTTP/1.1, HTTP/2)                | TCP (через `Upgrade: websocket`)                   |
| **Нагрузка**                | Выше — каждый запрос несёт полные заголовки | Ниже — постоянный поток без повторных заголовков   |
| **Типовые применения**      | API, страницы, формы                        | Чаты, уведомления, игры, данные в реальном времени |

</details>

---

<details>
<summary><span>21. На каких <b>портах</b> работают протоколы <b>HTTP</b>, <b>HTTPS</b> и <b>WebSocket</b>?</span></summary>
<br />

Вот стандартные порты для этих протоколов:

| Протокол    | Описание                     | Стандартный порт |
| ----------- | ---------------------------- | ---------------- |
| `HTTP`      | Незащищённый веб-протокол    | `80`             |
| `HTTPS`     | HTTP с шифрованием (TLS/SSL) | `443`            |
| `WebSocket` | Без шифрования (`ws://`)     | `80`             |
| `WebSocket` | С шифрованием (`wss://`)     | `443`            |

Важно: WebSocket использует тот же порт, что и HTTP/HTTPS, так как подключение начинается с обычного HTTP-запроса с заголовком `Upgrade: websocket`.

</details>

---

<details>
<summary><span>22. Какой HTTP-заголовок используется для установления WebSocket-соединения?</span></summary>
<br />

Для установления WebSocket-соединения клиент отправляет **HTTP-запрос** с несколькими специальными заголовками. Самые важные:

- **`Upgrade: websocket`** — указывает, что клиент хочет перейти с HTTP на WebSocket-протокол.
- **`Connection: Upgrade`** — сообщает, что заголовок `Upgrade` актуален для этого соединения.
- **`Sec-WebSocket-Key`** — случайная строка, используемая для проверки подлинности при рукопожатии.
- **`Sec-WebSocket-Version`** — версия протокола WebSocket (обычно `13`).

Пример запроса:

```
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Version: 13
```

После этого сервер отвечает статусом `101 Switching Protocols`, и устанавливается постоянное соединение WebSocket.

</details>

---

<details>
<summary><span>23. Какой метод используется для отправки данных через WebSocket?</span></summary>
<br />

Для отправки данных через WebSocket используется **метод `send()`**.

После установления соединения (например, через `new WebSocket()` в JavaScript), клиент может передавать данные на сервер так:

```js
const socket = new WebSocket('wss://example.com');
socket.onopen = () => {
	socket.send('Привет, сервер!');
};
```

Метод `send()` может отправлять:

- строки (текстовые данные),
- двоичные данные (`Blob`, `ArrayBuffer` и т. д.).

Важно: перед вызовом `send()` нужно дождаться события `onopen`, чтобы убедиться, что соединение установлено.

</details>

---

<details>
<summary><span>24. Какой метод используется для закрытия WebSocket-соединения?</span></summary>
<br />

Для закрытия WebSocket-соединения используется метод **`close()`**.

Пример:

```js
const socket = new WebSocket('wss://example.com');

// Закрытие соединения
socket.close();
```

Метод `close()` можно вызывать:

- без аргументов — просто закрыть соединение,
- с кодом и сообщением: `socket.close(1000, "Завершаем")`  
  где `1000` — стандартный код закрытия (нормальное завершение), а `"Завершаем"` — причина (опционально).

После вызова `close()`:

- Генерируется событие `onclose`, в котором можно обработать завершение соединения.

</details>

---

<details>
<summary><span>25. Какие данные можно передавать через WebSocket?</span></summary>
<br />

- **Текстовые строки** — обычный текст, часто в формате JSON.
- **JSON-объекты** — передаются как строки (после `JSON.stringify`).
- **ArrayBuffer** — двоичные данные в виде массива байт.
- **Blob** — для передачи файлов и других бинарных данных (в браузере).
- **TypedArray** — например, `Uint8Array`, `Float32Array` и др.
- **Buffer** — в среде Node.js для работы с бинарными данными.

</details>

---

<details>
<summary><span>26. Что происходит, если WebSocket-соединение разрывается?</span></summary>
<br />

Когда WebSocket-соединение разрывается на клиенте автоматически срабатывает событие **`onclose`**.

```js
socket.onclose = event => {
	console.log('Соединение закрыто');
	console.log('Код:', event.code); // Например, 1000 — нормальное закрытие
	console.log('Причина:', event.reason); // Причина, если указана
	console.log('Чисто ли закрыто:', event.wasClean); // true/false
};
```

---

### Что можно сделать при разрыве:

- **Показать уведомление пользователю** — чтобы он знал, что соединение потеряно.
- **Реализовать переподключение** — например, с задержкой или повторными попытками:
- **Проанализировать код закрытия** — решить, стоит ли восстанавливать соединение (`1000` — нормально, `1006` — сбой).
- **Очистить связанные ресурсы** — отключить таймеры, обнулить состояние, скрыть UI и т. д.

</details>

---

<details>
<summary><span>27. Какое событие используется для обработки входящих сообщений в WebSocket?</span></summary>
<br />

Для обработки входящих сообщений в WebSocket используется событие **`onmessage`**.

Это событие срабатывает каждый раз, когда от сервера приходит новое сообщение.  
Внутри обработчика можно получить доступ к данным через `event.data`.

### Пример использования:

```js
const socket = new WebSocket('wss://example.com');

socket.onmessage = event => {
	console.log('Получено сообщение:', event.data);
};
```

Поле `event.data` может содержать:

- строку (например, JSON),
- бинарные данные (если сервер отправляет `ArrayBuffer` или `Blob`).

</details>

---

<details>
<summary><span>28. Какое событие возникает при успешном установлении WebSocket-соединения?</span></summary>
<br />

После успешного установления соединения с сервером WebSocket на клиенте срабатывает событие **`onopen`**.

Это событие означает, что канал связи открыт, и можно начинать обмен данными.

### Пример использования:

```js
const socket = new WebSocket('wss://example.com');

socket.onopen = () => {
	console.log('Соединение установлено!');
	socket.send('Привет, сервер!');
};
```

</details>

---

<details>
<summary><span>29. Какой код закрытия WebSocket указывает на нормальное завершение соединения?</span></summary>
<br />

Код **`1000`** обозначает **нормальное завершение WebSocket-соединения**.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />

</details>

--- -->
