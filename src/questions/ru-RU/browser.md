<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/browser.png">
  <h2>Браузер</h2>
</div>
<br />

<details>
<summary><span>1. Что происходит от момента ввода URL в адресную строку и нажатия Enter до получения и рендеринга HTML в браузере?</span></summary>
<br />

### **1. Ввод URL и разбор**

- Пользователь вводит URL, например `https://example.com`.
- Браузер анализирует URL и определяет:
  - Протокол (`https`)
  - Доменное имя (`example.com`)
  - Путь, параметры, якорь (если есть)

---

### **2. Проверка кэша**

Браузер перед запросом проверяет локальные источники:

- **DNS-кэш** (если IP-адрес уже запрашивался ранее)
- **Кэш HTTP** (если страница была загружена и сохранена)
- **Service Worker** (если настроен, может обработать запрос)

Если IP-адрес найден в кэше, этап DNS-резолвинга пропускается.

---

### **3. DNS-резолвинг и поиск IP-адреса**

Если в кэше нет IP, браузер делает DNS-запрос. Запрос проходит несколько этапов, двигаясь по цепочке серверов:

1. **Локальный DNS** (провайдер интернета) проверяет наличие записи.
2. Если записи нет, запрос передаётся на **корневые DNS-серверы**.
3. Корневой сервер направляет запрос на **сервер доменной зоны** (например, `.com`).
4. Сервер доменной зоны направляет к **авторитетному DNS-серверу сайта** (например, DNS `example.com`).
5. Авторитетный сервер возвращает **IP-адрес** соответствующего домена.

В результате `example.com` → `93.184.216.34`.

---

### **4. Установка TCP-соединения**

Браузер устанавливает соединение с полученным IP через **TCP**:

- Открывается соединение на порт **80 (HTTP) или 443 (HTTPS)**.
- Используется **трёхстороннее рукопожатие** (three-way handshake). Этот процесс состоит из трёх шагов:

  - Браузер (клиент) отправляет **SYN-пакет** на сервер, запрашивая установление соединения.
  - Сервер принимает SYN-запрос и отвечает **SYN-ACK-пакетом**, подтверждая готовность к соединению.
  - Клиент получает SYN-ACK и отправляет **ACK-пакет**, подтверждая установление соединения.

---

### **5. TLS-рукопожатие (для HTTPS)**

Для защищённого соединения браузер и сервер:

- Обмениваются сертификатами.
- Устанавливают общий **ключ шифрования** (SSL/TLS).

---

### **6. Отправка HTTP-запроса**

Браузер отправляет **HTTP-запрос**:

```
GET / HTTP/1.1
Host: example.com
User-Agent: Chrome/...
Accept: text/html
```

---

### **7. Сервер получает и обрабатывает запрос**

- Сервер принимает запрос и формирует **HTTP-ответ**:
  - Если сайт динамический, может использовать backend (Node.js, PHP, Python и др.).
  - Если страница статическая, отдаёт HTML-файл.

---

### **8. Ответ сервера**

Сервер отправляет **HTTP-ответ**:

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: ...
```

</details>

---

<details>
<summary><span>2. Что такое <b>CRP</b>?</span></summary>
<br />

**Critical Rendering Path (CRP)** — это последовательность шагов, которые браузер выполняет, чтобы преобразовать HTML, CSS и JavaScript в полноценную веб-страницу, отображаемую на экране

</details>

---

<details>
<summary><span>3. Из каких этапов состоит <b>CRP</b>?</span></summary>
<br />

1. **Парсинг HTML** – браузер загружает HTML и строит DOM-дерево

2. **Обработка CSS** – загружается CSS и формируется CSSOM (модель стилей)

3. **Построение Render Tree** – объединяются DOM и CSSOM, формируя структуру элементов для рендеринга

4. **Этап Layout (вычисление расположения)** – браузер рассчитывает размеры и позиции элементов на странице

5. **Этап Painting (отрисовка)** – пиксели переводятся в визуальное представление, отрисовывая контент

6. **Этап Compositing (сборка слоев)** – финальный этап, где элементы объединяются в единое изображение и отображаются на экране

</details>

---

<details>
<summary><span>4. Что реально блокирует рендеринг страницы?</span></summary>
<br />

1. **CSS-файлы** – внешние таблицы стилей блокируют рендеринг до их полной загрузки и обработки браузером, так как влияют на внешний вид страницы.

2. **Синхронный JavaScript (`<script>` без `defer` или `async`)** – приостанавливает парсинг HTML, задерживая построение DOM и начало рендеринга.

3. **Web Fonts (шрифты)** – если используется `font-display: auto` или `block`, браузер может скрыть текст (FOIT), дожидаясь загрузки шрифта.

4. **`@import` в CSS** – особенно при вложенном импорте, замедляет загрузку и обработку стилей, блокируя рендеринг.

</details>

---

<details>
<summary><span>5. В каких случаях js файл следует размещать перед закрывающимся тегом <b>body</b>?</span></summary>
<br />

1. **Когда скрипт зависит от HTML-элементов** – если JavaScript работает с DOM (`document.getElementById`, `querySelector`), важно, чтобы элементы уже были загружены и доступны для изменений.

2. **Когда JavaScript взаимодействует со стилями** – если скрипт изменяет CSS или зависит от `getComputedStyle()`, важно, чтобы браузер сначала сформировал CSSOM и применил стили.

Размещение перед `</body>` также позволяет избежать блокировки рендеринга.

</details>

---

<details>
<summary><span>6. Что может вызвать <b>reflow</b>?</span></summary>
<br />

1. **Изменение размеров элемента** – установка или изменение `width`, `height`, `padding`, `margin`, `border`, `box-sizing` и других параметров, влияющих на геометрию.

2. **Добавление или удаление элементов в DOM** – любое изменение DOM-структуры (добавление, удаление, перемещение узлов) может повлиять на layout.

3. **Изменение стилей, влияющих на layout** – например, `display`, `position`, `float`, `font-size`, `line-height`.

4. **Вычисление размеров через JavaScript** – вызовы `getBoundingClientRect()`, `offsetWidth`, `scrollHeight` и др. могут вызвать принудительный reflow, если перед этим DOM был изменён.

5. **Изменение шрифтов** – загрузка нового шрифта (`@font-face`) или смена `font-family` может изменить размеры текста и вызвать перерасчёт.

6. **Изменение layout-свойств во время анимации** – свойства вроде `top`, `left`, `width`, `height` (особенно без GPU-оптимизации) вызывают reflow.

7. **Редактируемые области (`contenteditable`)** – изменение текста или вставка контента внутри может вызывать reflow во время взаимодействия пользователя.

8. **Сложные структуры (например, таблицы)** – таблицы с взаимозависимыми размерами ячеек чаще вызывают reflow и требуют больше вычислений.

</details>

---

<details>
<summary><span>7. Какие есть способы оптимизировать <b>CRP</b>?</span></summary>
<br />

1. **Сокращение количества критических ресурсов**  
   — удаление неиспользуемых CSS и JS  
   — откладывание загрузки некритичных ресурсов (ленивая загрузка)

2. **Минимизация блокирующих рендеринг ресурсов**  
   — использование атрибутов `async` и `defer` для скриптов  
   — вынос критичных стилей в `<style>` (critical CSS), остальное — отложенно

3. **Минимизация размеров критических ресурсов**  
   — минификация CSS, JS, HTML  
   — сжатие через Gzip или Brotli

4. **Оптимизация количества HTTP-запросов**  
   — объединение файлов (bundling)  
   — инлайнинг критических стилей и скриптов

5. **Оптимизация порядка загрузки ресурсов**  
   — приоритетная загрузка ресурсов, необходимых для первого экрана  
   — отложенная загрузка неважного контента (`lazy loading`)

6. **Использование `<preload>`, `<prefetch>`, `<preconnect>`**  
   — `preload` — ранняя загрузка критических ресурсов  
   — `prefetch` — предварительная загрузка ресурсов, которые понадобятся позже  
   — `preconnect` — предварительное соединение с внешними доменами (например, шрифты, аналитика)

7. **Использование CDN (Content Delivery Network)**  
   — ускорение загрузки за счёт доставки ресурсов с ближайших серверов

</details>

---

<details>
<summary><span>8. Расскажите про хранилища, которые есть в браузере?</span></summary>
<br />

| Хранилище          | Объём данных                             | Срок хранения                                                          | Доступность                                    | Особенности                                                                 |
| ------------------ | ---------------------------------------- | ---------------------------------------------------------------------- | ---------------------------------------------- | --------------------------------------------------------------------------- |
| **Cookies**        | ~4 KB на cookie                          | Устанавливается сервером или JavaScript, может быть ограничен временем | Отправляются на сервер при каждом HTTP-запросе | Используются для аутентификации, хранения пользовательских настроек         |
| **LocalStorage**   | До 5–10 MB                               | Пока пользователь вручную не удалит                                    | Только внутри текущего домена                  | Хранение данных между сессиями, синхронный API                              |
| **SessionStorage** | До 5–10 MB                               | До закрытия вкладки браузера                                           | Только в рамках одной вкладки                  | Для временного хранения данных, уникальных для вкладки                      |
| **IndexedDB**      | Ограничено только дисковым пространством | Долговременное хранение                                                | Только в браузере                              | Асинхронное хранилище для структурированных данных, поддерживает транзакции |
| **Cache Storage**  | Зависит от браузера и политики           | Долговременное хранение                                                | Только в браузере                              | Используется в Service Worker для кэширования ресурсов (например, в PWA)    |

</details>

---

<!--
<details>
<summary><span></span></summary>
<br />

</details>

--- -->

<!--
браузерные апи
Какие могут быть кейсы использования session storage (хранение токена через замыкание)
Ошибка корсов
 -->
