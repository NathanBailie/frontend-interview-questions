<a href="../../../README.md">← Назад</a>

<div align="center">
  <img src="../../../src/assets/icons/icons-for-titles/ts.png">
  <h2>Вопросы по TypeScript</h2>
</div>
<br />

<details>
<summary><span>1. Что такое TypeScript?</span></summary>
<br />

**TypeScript** — это надмножество JavaScript, добавляющее в него поддержку статической типизации

</details>

---

<details>
<summary><span>2. Какие преимущества дает TypeScript?</span></summary>
<br />

- Статическая типизация помогает находить ошибки на этапе разработки
- Улучшает читаемость и поддерживаемость кода
- Обеспечивает более качественную поддержку IDE (автодополнение, рефакторинг)
- Позволяет безопасно рефакторить крупные проекты
- Упрощает документирование кода через типы
- Улучшает командную разработку благодаря явным контрактам
- Обратная совместимость с JavaScript
- Поддержка современных возможностей ECMAScript
- Возможность постепенного внедрения в проект

</details>

---

<details>
<summary><span>3. Какие недостатки есть у TypeScript?</span></summary>
<br />

- Нужна компиляция в JavaScript — добавляет шаг в сборке.
- Типизация требует времени — код пишется дольше.
- Порог входа выше, особенно для новичков.
- Код становится больше — из-за описания типов.
- Нужны доп. инструменты — компилятор, конфиги и т.п.
- Не все библиотеки типизированы корректно — возможны ошибки.
- Сложные типы могут запутать — особенно при чрезмерном использовании.
- Типы не гарантируют безопасность — можно обойти через `any`.

</details>

---

<details>
<summary><span>4. Какие типы данных существуют в TypeScript?</span></summary>
<br />

Вот краткая структура типов данных в **TypeScript**:

1. **Примитивные типы**  
   – string  
   – number  
   – boolean  
   – bigint  
   – symbol  
   – null  
   – undefined

2. **Специальные типы**  
   – any  
   – unknown  
   – never  
   – void

3. **Составные типы**  
   – интерфейсы (`interface`)  
   – типы (`type`)

4. **Union и Intersection типы**  
   – объединение (`|`)  
   – пересечение (`&`)

5. **Литеральные типы**  
   – строковые  
   – числовые  
   – булевы  
   – шаблонные  
   – составные литералы

6. **Обобщённые типы (Generics)**

</details>

---

<details>
<summary><span>5. Для чего нужен модификатор необязательного свойства?</span></summary>
<br />

Модификатор необязательного свойства (`?`) позволяет указать, что свойство объекта может отсутствовать. Это полезно, когда некоторые поля являются опциональными.

</details>

---

<details>
<summary><span>6. Какие недостатки у типа any?</span></summary>
<br />

1. Отключает проверку типов — возможны ошибки во время выполнения.
2. Снижает безопасность и надёжность кода.
3. Усложняет рефакторинг и автодополнение — IDE теряет информацию о типах.
4. Ухудшает читаемость — непонятно, какие данные ожидаются.
5. Скрывает реальные проблемы с типами.
6. Снижает долгосрочную поддержку — код становится труднее сопровождать.

</details>

---

<details>
<summary><span>7. Когда используется тип unknown?</span></summary>
<br />

`unknown` — это безопасная альтернатива `any`, которую используют, когда тип данных заранее неизвестен и требует проверки перед использованием.

</details>

---

<details>
<summary><span>8. Что делает тип void?</span></summary>
<br />

Тип `void` используется для указания, что функция не возвращает значения

</details>

---

<details>
<summary><span>9. Для чего используется тип never?</span></summary>
<br />

Тип `never` используется для обозначения значений, которые никогда не возникают.

Например:

1. В функциях, которые не завершаются нормально — например, выбрасывают исключение или зацикливаются бесконечно.
2. В проверках на исчерпывающие варианты — как в `switch-case`, чтобы убедиться, что обработаны все возможные типы.
3. В условных типах с `infer` — для извлечения, исключения или проверки типов, основанных на значении

</details>

---

<details>
<summary><span>10. Что такое сужение типов?</span></summary>
<br />

Это процесс уточнения неизвестного или объединённого типа до более конкретного значения на основе условий в коде.

</details>

---

<details>
<summary><span>11. Какими способами можно сузить тип?</span></summary>
<br />

1. `typeof` — проверка примитивных типов
2. `in` — проверка наличия свойства в объекте
3. `instanceof` — проверка принадлежности к классу
4. Пользовательские type guards — с использованием функций с `is`
5. Дискриминантные объединения — по уникальному свойству
6. Проверка на `null` и `undefined`
7. Проверка на истинность/ложность — для исключения falsy-значений
8. Сравнение с литеральными значениями

</details>

---

<details>
<summary><span>12. Для чего используется утилита <b>as const</b>?</span></summary>
<br />

Утилита `as const` используется для превращения значения в **неизменяемый литеральный тип**, делая все его свойства `readonly`.

```ts
const status = {
	success: 'SUCCESS',
	error: 'ERROR',
} as const;
```

</details>

---

<details>
<summary><span>13. Что такое надтип(supertype) и подтип(subtype)?</span></summary>
<br />

**Надтип (supertype)** — это более общий тип, который охватывает множество значений и может включать в себя другие, более специфичные типы.

**Подтип (subtype)** — это частный случай надтипа, который соответствует его структуре и может быть использован там, где ожидается надтип.

Проще говоря:

> **Подтип можно передать туда, где ожидается надтип, но не наоборот.**

Например, `string` — подтип `string | number`, потому что он соответствует более широкому объединению.

</details>

---

<details>
<summary><span>14. Что такое дженерик?</span></summary>
<br />

**Дженерик (Generic)** — это параметризованный тип, который позволяет писать код, работающий с разными типами данных, сохраняя при этом типобезопасность.

</details>

---

<details>
<summary><span>15. Как ограничить дженерик?</span></summary>
<br />

Дженерики можно ограничить с помощью ключевого слова `extends`. Это позволяет указать, что тип-параметр должен быть подтипом определенного типа.

</details>

---

<details>
<summary><span>16. Что такое условные типы?</span></summary>
<br />

Это типы, которые определяются на основе условия: они принимают одно значение, если условие истинно, и другое — если ложно.

Работают по принципу A extends **B ? X : Y**, где результат зависит от того, соответствует ли тип A типу B.

</details>

---

<details>
<summary><span>17. В чем польза условных типов?</span></summary>
<br />

1. **Гибкости типов** — позволяют задавать типы динамически, в зависимости от других.
2. **Типобезопасности** — помогают точнее контролировать типы на основе условий.
3. **Упрощения логики типов** — позволяют выразить сложные конструкции проще, чем через `union`.
4. **Создания utility-типов** — большинство встроенных служебных типов TypeScript основаны на условных.
5. **Проверки типов** — позволяют валидировать типы и ветвить поведение на уровне типовой системы.

</details>

---

<details>
<summary><span>18. Что такое type guards?</span></summary>
<br />

**Type guards** — это конструкции в TypeScript, которые позволяют определить точный тип переменной во время выполнения и сужать её тип внутри блока кода, обеспечивая безопасную работу с данными.

</details>

---

<details>
<summary><span>19. Что такое преобразование типов?</span></summary>
<br />

**Преобразование типов** — это процесс приведения значения одного типа к другому, чтобы его можно было использовать в соответствующем контексте.

В TypeScript бывает:

- **Неявное (implicit)** — TypeScript сам преобразует тип, например:

  ```ts
  const num = '5' as any;
  const doubled = num * 2; // num стал числом
  ```

- **Явное (explicit / type assertion)** — ты сам указываешь, к какому типу нужно привести:
  ```ts
  const value = input as string;
  ```

</details>

---

<details>
<summary><span>20. Что такое type assertion?</span></summary>
<br />

**Type assertion** в TypeScript — это способ _явно привести значение к нужному типу_, когда ты уверен, что знаешь его точнее, чем компилятор.

Пример приведения типа с помощью `as`:

```ts
const someValue: unknown = 'Hello, TypeScript';

const strLength = (someValue as string).length;

console.log(strLength); // 17
```

</details>

---

<details>
<summary><span>21. Почему небезопасно использовать приведение типа через <b>as</b>?</span></summary>
<br />

Использование `as` в TypeScript может быть небезопасным, потому что оно принудительно указывает тип, не проверяя соответствие значения — это может привести к ошибкам во время выполнения. Такой подход отключает типовую защиту, ради которой используется TypeScript.

</details>

---

<details>
<summary><span>22. Когда допустимо использовать <b>as</b>?</span></summary>
<br />

Использовать `as` допустимо, когда:

1. **Ты точно знаешь тип значения**, а TypeScript не может его вывести:

   ```ts
   const input = document.getElementById('email') as HTMLInputElement;
   input.value = 'example@example.com';
   ```

2. **Ты работаешь с `unknown` или `any`**, но уже проверил тип вручную:

   ```ts
   function handle(value: unknown) {
   	if (typeof value === 'string') {
   		const length = (value as string).length;
   	}
   }
   ```

3. **После `JSON.parse` или внешних данных**, когда тип известен только тебе:

   ```ts
   const user = JSON.parse(data) as User;
   ```

4. **Когда нужно принудительно привести несовместимые типы через `unknown`**:
   ```ts
   const point = { x: 1, y: 2 } as unknown as [number, number];
   ```

</details>

---

<details>
<summary><span>23. Чем отличаются <b>as</b> и <b>satisfies</b>?</span></summary>
<br />

**`as` — приведение типа (type assertion):**

- Позволяет явно указать тип значения вручную.
- Не проверяет фактическое соответствие типа.
- Обрезает лишние свойства и **может потерять точные типы**.
- Используется, когда:
  - нужно "подсказать" тип компилятору;
  - работаешь с `unknown` или `any`;
  - нужно привести несовместимые типы через `as unknown as`.

---

**`satisfies` — проверка соответствия типу (type constraint):**

- Проверяет, соответствует ли объект указанному типу.
- **Сохраняет точные типы и дополнительные поля**.
- Не приводит значение к типу — только проверяет на этапе компиляции.
- Используется, когда:
  - нужна проверка соответствия типу без потери информации;
  - важно сохранить узкие типы (например, `readonly`, `const`);
  - задаются объектные литералы или конфигурации.

</details>

---

<details>
<summary><span>24. Что делает оператор <b>keyof</b>?</span></summary>
<br />

Оператор `keyof` в TypeScript возвращает множество ключей переданного типа объекта в виде объединения строковых литералов.

</details>

---

<details>
<summary><span>25. Что делает оператор <b>typeof</b>?</span></summary>
<br />

Оператор `typeof` в TypeScript возвращает строку, указывающую тип примитивного значения или используется на этапе типизации для получения типа переменной.

</details>

---

<details>
<summary><span>26. Что делает <b>оператор опциональной цепочки</b>(?.)?</span></summary>
<br />

Оператор опциональной цепочки `?.` позволяет безопасно обращаться к свойствам или методам объекта, которые могут быть `null` или `undefined`, без выброса ошибки.

</details>

---

<details>
<summary><span>27. Что делает <b>non null assertion operator (!)</b>?</span></summary>
<br />

Оператор `!` (non-null assertion) в TypeScript говорит компилятору, что значение **точно не `null` и не `undefined`**, и позволяет обращаться к его свойствам без ошибок проверки типов.

</details>

---

<details>
<summary><span>28. Что такое <b>enum</b>?</span></summary>
<br />

`enum` (перечисление) в TypeScript — это способ задать набор именованных констант, которым автоматически присваиваются числовые или строковые значения.

</details>

---

<details>
<summary><span>29. Какие есть проблемы у <b>enum</b>?</span></summary>
<br />

- Неявное поведение при компиляции — создаёт дополнительный JS-код.
- Не работает с `const`-контекстом — не даёт жёсткой типизации как `as const`.
- Может приводить к ошибкам при сравнении строковых значений (особенно при сериализации).
- Не поддерживает автодополнение значений в некоторых случаях.
- Хуже интегрируется с современными инструментами (`const enum` требует спецнастроек).

💡 Альтернатива — использовать `as const` с объектами или строковыми литералами.

</details>

---

<details>
<summary><span>30. В чем отличие <b>enum</b> от <b>объекта</b>?</span></summary>
<br />

**`enum`** и обычный объект в TypeScript различаются по поведению, назначению и результату компиляции:

- **`enum`**:

  - создаёт специальную структуру с именованными значениями (числовыми или строковыми);
  - поддерживает **обратное сопоставление** (только для числовых `enum`);
  - генерирует **дополнительный JavaScript-код** (объект на уровне runtime);
  - может использоваться как тип, но **не всегда защищает от присваивания произвольных значений**;
  - подходит для случаев, где важно наличие значений на runtime.

- **объект (`as const`)**:

  - проще, не создаёт лишнего кода в JS;
  - совместим с `as const`, что даёт **строгую литеральную типизацию**;
  - не поддерживает обратное сопоставление;
  - идеален для конфигураций, API-констант и сериализации;
  - позволяет получить **перечисление значений** через `keyof typeof`.

💡 Если нужна лёгкость, типобезопасность и работа только на уровне типов — лучше использовать объект с `as const`. Если важно наличие значений во время выполнения — можно использовать `enum`.

</details>

---

<details>
<summary><span>31. Разница между <b>type</b> и <b>interface</b>?</span></summary>
<br />

- **`interface`**:

  - предназначен в первую очередь для описания структур объектов и классов;
  - поддерживает расширение через `extends` и реализацию в классах через `implements`;
  - поддерживает **декларативное слияние** — интерфейсы с одинаковым именем автоматически объединяются;
  - предпочтителен, когда нужно моделировать публичный API объекта или класса.

- **`type`**:

  - создаёт псевдонимы **любых типов**: примитивов, объединений (`|`), пересечений (`&`), кортежей, функций и т.д.;
  - не поддерживает слияние по имени;
  - более гибок и мощен при работе со сложными типами и их комбинациями.

💡 В современном TypeScript они во многом взаимозаменяемы. Обычно `interface` используется для описания объектов и классов, а `type` — для более общих и сложных типов.

</details>

---

<details>
<summary><span>32. Что такое структурная типизация?</span></summary>
<br />

**Структурная типизация** — это принцип, при котором типы считаются совместимыми, если у них **совпадает структура**, независимо от имени типа или интерфейса.

В TypeScript это означает, что объект подходит под интерфейс, если он содержит **все необходимые свойства с нужными типами**, даже без явной реализации. Такой подход напоминает концепцию _duck typing_:
**"Если что-то выглядит как тип и ведёт себя как тип — оно и есть этот тип."**

</details>

---

<details>
<summary><span>33. Почему стоит относиться к типам как ко <b>множествам</b>?</span></summary>
<br />

В TypeScript типы удобно рассматривать как **множества возможных значений**, что позволяет легче понимать операции над ними:

- **объединение** (`|`) — объединяет множества значений;
- **пересечение** (`&`) — создаёт множество, общее для обоих типов;
- **наследование** (`extends`) — работает как отношение подмножества;
- **`never`** — представляет пустое множество.

Такой подход помогает интуитивно рассуждать о типах, совместимости и преобразованиях.
💡 Мышление через множества делает систему типов более предсказуемой, логичной и удобной при проектировании сложных типов.

</details>

---

<details>
<summary><span>34. Что такое <b>mapped types</b>?</span></summary>
<br />

**Mapped types** — это способ создавать новые типы на основе существующих, перебирая их ключи с помощью конструкции `in` и трансформируя каждое свойство по заданному шаблону.

Например:

```ts
type Readonly<T> = {
	readonly [K in keyof T]: T[K];
};
```

</details>

---

<details>
<summary><span>35. Какие вы знаете утилитарные типы?</span></summary>
<br />

- `Partial<T>` — делает все свойства типа необязательными.
- `Required<T>` — делает все свойства обязательными.
- `Readonly<T>` — делает все свойства только для чтения.
- `Pick<T, K>` — выбирает указанные свойства из типа.
- `Omit<T, K>` — исключает указанные свойства из типа.
- `Exclude<T, U>` — исключает из `T` те типы, что входят в `U`.
- `Extract<T, U>` — извлекает из `T` те типы, что входят в `U`.
- `Record<K, T>` — создаёт объект с ключами `K` и значениями типа `T`.
- `NonNullable<T>` — исключает `null` и `undefined` из типа.
- `ReturnType<T>` — получает тип возвращаемого значения функции.
- `Parameters<T>` — получает типы параметров функции в виде кортежа.
- `Awaited<T>` — извлекает тип из `Promise` (или цепочки `Promise`).

</details>

---

<details>
<summary><span>36. Что такое <b>asserts</b>?</span></summary>
<br />

`asserts` — это ключевое слово в TypeScript, используемое в сигнатуре функции, чтобы указать: если функция завершается без ошибки, то указанный тип можно считать проверенным.

Такая функция называется **assertion function** и помогает сужать типы вручную.
Пример:

```ts
function assertIsString(value: unknown): asserts value is string {
	if (typeof value !== 'string') {
		throw new Error('Not a string');
	}
}
```

После вызова `assertIsString(value)` компилятор будет считать `value` строкой.

</details>

---

<details>
<summary><span>37. Что такое перегрузка функций?</span></summary>
<br />

**Перегрузка функций** — это возможность объявлять несколько сигнатур функции с одним именем, отличающихся типами и/или количеством параметров, чтобы TypeScript мог выбрать правильную версию при вызове в зависимости от переданных аргументов.

Реализация — одна функция с конкретным телом, которая обрабатывает все варианты.

Пример:

```ts
function parse(input: string): number;
function parse(input: number): string;
function parse(input: any): any {
	if (typeof input === 'string') {
		return Number(input);
	}
	if (typeof input === 'number') {
		return String(input);
	}
}
```

</details>

---

<details>
<summary><span>37. Для чего нужен <b>infer</b>?</span></summary><br />

Ключевое слово <code>infer</code> используется в условных типах TypeScript, чтобы вывести тип из структуры другого типа.

Это позволяет динамически извлекать вложенные типы и переиспользовать их.

Примеры:

```ts
// Извлекаем тип параметров функции
type Params<T> = T extends (...args: infer A) => any ? A : never;
// Результат: [x: number, y: number]
type ExampleParams = Params<(x: number, y: number) => void>;

// Извлекаем возвращаемый тип функции
type Return<T> = T extends (...args: any[]) => infer R ? R : never;
// Результат: string
type ExampleReturn = ReturnF<() => string>;
```

</details>

---

<!--
Декораторы
Отличие Omit от Exclude
Что такое прокси класс?

 -->

 <!-- <details>
<summary><span></span></summary>
<br />


</details>

--- -->
