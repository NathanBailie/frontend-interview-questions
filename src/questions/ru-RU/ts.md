<a href="../../../README.md">← Назад</a>

<div align="center">
  <img src="../../../src/assets/icons/icons-for-titles/ts.png">
  <h2>Вопросы по TypeScript</h2>
</div>
<br />

<details>
<summary><span>1. Что такое TypeScript?</span></summary>
<br />

**TypeScript** — это надмножество JavaScript, добавляющее в него поддержку статической типизации

</details>

---

<details>
<summary><span>2. Какие преимущества дает TypeScript?</span></summary>
<br />

- Статическая типизация помогает находить ошибки на этапе разработки
- Улучшает читаемость и поддерживаемость кода
- Обеспечивает более качественную поддержку IDE (автодополнение, рефакторинг)
- Позволяет безопасно рефакторить крупные проекты
- Упрощает документирование кода через типы
- Улучшает командную разработку благодаря явным контрактам
- Обратная совместимость с JavaScript
- Поддержка современных возможностей ECMAScript
- Возможность постепенного внедрения в проект

</details>

---

<details>
<summary><span>3. Какие недостатки есть у TypeScript?</span></summary>
<br />

- Нужна компиляция в JavaScript — добавляет шаг в сборке.
- Типизация требует времени — код пишется дольше.
- Порог входа выше, особенно для новичков.
- Код становится больше — из-за описания типов.
- Нужны доп. инструменты — компилятор, конфиги и т.п.
- Не все библиотеки типизированы корректно — возможны ошибки.
- Сложные типы могут запутать — особенно при чрезмерном использовании.
- Типы не гарантируют безопасность — можно обойти через `any`.

</details>

---

<details>
<summary><span>4. Какие типы данных существуют в TypeScript?</span></summary>
<br />

Вот краткая структура типов данных в **TypeScript**:

1. **Примитивные типы**  
   – string  
   – number  
   – boolean  
   – bigint  
   – symbol  
   – null  
   – undefined

2. **Специальные типы**  
   – any  
   – unknown  
   – never  
   – void

3. **Составные типы**  
   – интерфейсы (`interface`)  
   – типы (`type`)

4. **Union и Intersection типы**  
   – объединение (`|`)  
   – пересечение (`&`)

5. **Литеральные типы**  
   – строковые  
   – числовые  
   – булевы  
   – шаблонные  
   – составные литералы

6. **Обобщённые типы (Generics)**

Хочешь, могу накинуть структуру с примерами или оформить это для шпаргалки. Сигнализируй, если надо.

</details>

---

<details>
<summary><span>5. Для чего нужен модификатор необязательного свойства?</span></summary>
<br />

Модификатор необязательного свойства (`?`) позволяет указать, что свойство объекта может отсутствовать. Это полезно, когда некоторые поля являются опциональными.

</details>

---

<details>
<summary><span>6. Какие недостатки у типа any?</span></summary>
<br />

1. Отключает проверку типов — возможны ошибки во время выполнения.
2. Снижает безопасность и надёжность кода.
3. Усложняет рефакторинг и автодополнение — IDE теряет информацию о типах.
4. Ухудшает читаемость — непонятно, какие данные ожидаются.
5. Скрывает реальные проблемы с типами.
6. Снижает долгосрочную поддержку — код становится труднее сопровождать.

</details>

---

<details>
<summary><span>7. Когда используется тип unknown?</span></summary>
<br />

`unknown` — это безопасная альтернатива `any`, которую используют, когда тип данных заранее неизвестен и требует проверки перед использованием.

</details>

---

<details>
<summary><span>8. Что делает тип void?</span></summary>
<br />

Тип `void` используется для указания, что функция не возвращает значения

</details>

---

<details>
<summary><span>9. Для чего используется тип never?</span></summary>
<br />

Тип `never` используется для обозначения значений, которые никогда не возникают.

Например:

1. В функциях, которые не завершаются нормально — например, выбрасывают исключение или зацикливаются бесконечно.
2. В проверках на исчерпывающие варианты — как в `switch-case`, чтобы убедиться, что обработаны все возможные типы.
3. В условных типах с `infer` — для извлечения, исключения или проверки типов, основанных на значении

</details>

---

<details>
<summary><span>10. Что такое сужение типов?</span></summary>
<br />

Это процесс уточнения неизвестного или объединённого типа до более конкретного значения на основе условий в коде.

</details>

---

<details>
<summary><span>11. Какими способами можно сузить тип?</span></summary>
<br />

1. `typeof` — проверка примитивных типов
2. `in` — проверка наличия свойства в объекте
3. `instanceof` — проверка принадлежности к классу
4. Пользовательские type guards — с использованием функций с `is`
5. Дискриминантные объединения — по уникальному свойству
6. Проверка на `null` и `undefined`
7. Проверка на истинность/ложность — для исключения falsy-значений
8. Сравнение с литеральными значениями

</details>

---

<details>
<summary><span>12. Для чего используется утилита <b>as const</b>?</span></summary>
<br />

Утилита `as const` используется для превращения значения в **неизменяемый литеральный тип**, делая все его свойства `readonly`.

```ts
const status = {
	success: 'SUCCESS',
	error: 'ERROR',
} as const;
```

</details>

---

<details>
<summary><span>13. Что такое надтип(supertype) и подтип(subtype)?</span></summary>
<br />

**Надтип (supertype)** — это более общий тип, который охватывает множество значений и может включать в себя другие, более специфичные типы.

**Подтип (subtype)** — это частный случай надтипа, который соответствует его структуре и может быть использован там, где ожидается надтип.

Проще говоря:

> **Подтип можно передать туда, где ожидается надтип, но не наоборот.**

Например, `string` — подтип `string | number`, потому что он соответствует более широкому объединению.

</details>

---

<details>
<summary><span>14. Что такое дженерик?</span></summary>
<br />

**Дженерик (Generic)** — это параметризованный тип, который позволяет писать код, работающий с разными типами данных, сохраняя при этом типобезопасность.

</details>

---

<details>
<summary><span>15. Как ограничить дженерик?</span></summary>
<br />

Дженерики можно ограничить с помощью ключевого слова `extends`. Это позволяет указать, что тип-параметр должен быть подтипом определенного типа.

</details>

---

<details>
<summary><span>16. Что такое условные типы?</span></summary>
<br />

Это типы, которые определяются на основе условия: они принимают одно значение, если условие истинно, и другое — если ложно.

Работают по принципу A extends **B ? X : Y**, где результат зависит от того, соответствует ли тип A типу B.

</details>

---

<details>
<summary><span>17. В чем польза условных типов?</span></summary>
<br />

1. **Гибкости типов** — позволяют задавать типы динамически, в зависимости от других.
2. **Типобезопасности** — помогают точнее контролировать типы на основе условий.
3. **Упрощения логики типов** — позволяют выразить сложные конструкции проще, чем через `union`.
4. **Создания utility-типов** — большинство встроенных служебных типов TypeScript основаны на условных.
5. **Проверки типов** — позволяют валидировать типы и ветвить поведение на уровне типовой системы.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />


</details>

--- -->
