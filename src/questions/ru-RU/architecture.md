<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/architecture.png">
  <h2>Архитектура</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>архитектура</b>?</span></summary>
<br />

**Архитектура** — это структурный подход к построению приложения, определяющий взаимодействие компонентов, обработку данных, масштабируемость и удобство сопровождения.

Можно сказать, что это совокупность ключевых решений, принятых на этапе проектирования, которые впоследствии сложно изменить — именно они задают вектор развития всей системы.

</details>

---

<details>
<summary><span>2. Какие основные проблемы должна решать архитектура?</span></summary>
<br />

Архитектура должна снижать зацепленность (coupling) — то есть минимизировать количество зависимостей между частями системы, — и одновременно управлять связанностью (cohesion), обеспечивая логичное объединение связанных элементов. Это позволяет системе быть гибкой, масштабируемой и легко расширяемой.

Также архитектура решает вопросы разделения ответственности, управляемости, тестируемости и устойчивости к изменениям.

</details>

---

<details>
<summary><span>3. Какие есть <b>атрибуты качества архитектуры</b> ?</span></summary>
<br />

Ключевые атрибуты качества архитектуры включают:

- **Читаемость (readability)** — облегчает понимание структуры и логики кода.
- **Переиспользуемость (reusability)** — позволяет использовать компоненты повторно без дублирования.
- **Слабая связанность и высокая зацепленность** — минимизируют зависимости и повышают устойчивость к изменениям.
- **Гибкость (flexibility)** — упрощает адаптацию архитектуры под меняющиеся бизнес-требования.
- **Надёжность (reliability)** — достигается через тестирование, ревью и контроль ошибок.
- **Поддерживаемость (maintainability)** — позволяет эффективно развивать и исправлять систему.
- **Тестируемость (testability)** — упрощает написание и выполнение тестов.

</details>

---

<details>
<summary><span>4. Почему вообще стоит задумываться над архитектурой?</span></summary>
<br />

Хорошая архитектура помогает создавать систему, которую проще масштабировать, сопровождать и адаптировать под новые требования. Она обеспечивает устойчивость к изменениям и упрощает командную работу.

Без архитектурного фундамента проект может быстро превратиться в хаос: правки становятся рискованными, развитие — замедляется, а сопровождение требует всё больше усилий.

</details>

---

<details>  
<summary><span>5. Какие вы знаете <b>принципы</b> и <b>методологии разработки</b>?</span></summary>  
<br />

- **DRY (Don’t Repeat Yourself)** — избегай дублирования кода и логики, выноси повторяющееся в отдельные единицы.
- **KISS (Keep It Simple, Stupid)** — простота важнее излишней умности, решения должны быть понятными и лаконичными.
- **SOC (Separation of Concerns)** — разделение ответственности: каждая часть системы должна заниматься своей задачей.
- **FF (Fail Fast)** — чем раньше система сообщает об ошибке, тем проще её отловить и устранить.
- **YAGNI (You Ain’t Gonna Need It)** — не стоит реализовывать то, что не требуется прямо сейчас.
- **SOLID** — методология построения надёжного и расширяемого ООП-кода, основанная на пяти принципах (Single Responsibility, Open/Closed и пр.).
- **TDD (Test-Driven Development)** — разработка через тестирование: сначала пишутся тесты, потом код, удовлетворяющий этим тестам.
- **TDA (Test-Driven Architecture)** — архитектура проектируется с учётом тестируемости, часто в связке с TDD.
- **DDD (Domain-Driven Design)** — проектирование вокруг предметной области, где архитектура отражает бизнес-логику.

Эти подходы помогают создавать код, который проще масштабировать, сопровождать и адаптировать.

</details>

---

<details>
<summary><span>6. Объясните принципы <b>SOLID</b>?</span></summary>
<br />

- **S — Single Responsibility Principle (SRP)**: каждый модуль должен отвечать только за одну часть функциональности, работая в одном домене
- **O — Open/Closed Principle (OCP)**: код должен быть открыт для расширения, но закрыт для модификации.
- **L — Liskov Substitution Principle (LSP)**: подклассы должны полноценно заменять базовые классы без нарушения логики.
- **I — Interface Segregation Principle (ISP)**: не стоит заставлять объект реализовывать интерфейс, который ему не нужен.
- **D — Dependency Inversion Principle (DIP)**: зависимости должны строиться от абстракций, а не от конкретных реализаций.

</details>

---

<details>  
<summary><span>7. Что такое чистая <b>архитектура</b>?</span></summary>  
<br />

**Чистая архитектура** — это подход к проектированию системы, при котором бизнес-логика отделена от инфраструктуры, пользовательского интерфейса и других внешних слоёв. Архитектура строится вокруг независимых слоёв, где зависимости направлены внутрь — к ядру приложения.

**Основные идеи:**

- В центре — бизнес-правила: сущности (Entities) и сценарии использования (Use Cases).
- Внешние слои (UI, базы данных, фреймворки) легко заменяемы.
- Связь между слоями осуществляется через абстракции (интерфейсы), реализуя принцип инверсии зависимостей.

Такой подход делает проект гибким, легко тестируемым и устойчивым к изменениям во внешней среде.

</details>

---

<details>
<summary><span>8. Из чего состоит <b>Атомарная архитектура</b>?</span></summary>
<br />

Атомарная архитектура — это подход к организации UI компонентов, основанный на принципах Atomic Design. Он делит интерфейс на уровни абстракции:

- **Atoms** — базовые элементы: кнопки, инпуты, иконки.
- **Molecules** — простые композиции атомов, например, форма авторизации.
- **Organisms** — более сложные блоки, состоящие из молекул и атомов, например, хедер.
- **Templates** — макеты страниц с расставленными организмами.
- **Pages** — конкретные реализации шаблонов с реальными данными.

Такой подход повышает переиспользуемость компонентов и упрощает поддержку дизайна.

</details>

---

<details>
<summary><span>9. Как устроена <b>Feature-Sliced Design</b> архитектура?/span></summary>
<br />

Feature-Sliced Design (FSD) — это подход к построению фронтенд-архитектуры, ориентированный на масштабируемость и удобство сопровождения крупных проектов. Он базируется на разделении по бизнес-сущностям и уровням абстракции.

**Основные уровни:**

- **App** — конфигурация и глобальная инициализация приложения.
- **Processes** — сквозные бизнес-процессы (например, оформление заказа).
- **Pages** — конкретные страницы, связывающие UI и бизнес-логику.
- **Widgets** — составные блоки, объединяющие несколько фичей и UI-элементов.
- **Features** — независимые бизнес-функции (например, фильтр товаров).
- **Entities** — модели и логика бизнес-сущностей (например, пользователь, товар).
- **Shared** — общие утилиты, компоненты, типы и стили, доступные всем слоям.

**Ключевые архитектурные принципы:**

- **Разделение логики и UI** внутри каждого модуля: бизнес-логика и визуальное представление обособлены для гибкости и тестируемости.
- **Импорты через Public API** — доступ к внешним модулям осуществляется только через строго определённый публичный интерфейс (`index.ts`).
- **Односторонняя направленность зависимостей:** можно импортировать из нижележащего слоя в верхний, но не наоборот. Исключение — слой `shared`, который доступен всем.

</details>

---

<details>
<summary><span>10. Что такое декларативность?</span></summary>
<br />

Декларативность — это стиль программирования, при котором разработчик описывает **что** должно быть сделано, а не **как** это должно выполняться. Вместо явных шагов, управление передаётся среде выполнения или фреймворку.

Примеры:

- В HTML: `<button disabled>` — мы не описываем, как именно кнопка становится неактивной.
- В Vue: `v-if="isVisible"` — мы говорим, что элемент отображается при определённом условии, не управляя DOM вручную.

Такой подход упрощает чтение кода, повышает его выразительность и снижает количество ошибок при взаимодействии с низкоуровневыми деталями.

</details>

---

<details>
<summary><span>11. Опишите основные <b>принципы ООП</b></span></summary>
<br />

- **Инкапсуляция** — сокрытие внутренней реализации и предоставление публичного интерфейса. Данные защищены от прямого вмешательства извне.
- **Наследование** — возможность создавать новые классы на основе существующих, повторно используя логику и расширяя функциональность.
- **Полиморфизм** — единый интерфейс для разных типов объектов. Позволяет вызывать методы без знания точного типа объекта.
- **Абстракция** — выделение ключевых характеристик объекта и сокрытие сложных деталей. Фокус на том, что важно, а не как это реализовано.

</details>

---

<details>
<summary><span>12. Когда стоит использовать ООП?</span></summary>
<br />

Объектно-ориентированное программирование (ООП) стоит использовать, когда:

- система содержит множество похожих сущностей с общими свойствами и поведением (например, пользователи, товары, заказы),
- требуется чёткое моделирование структуры и взаимодействий внутри приложения,
- проект большой и предполагает долгосрочное развитие,
- необходимо легко расширять и переиспользовать код (через наследование, интерфейсы и абстракции),
- используется язык с типизацией (например, TypeScript), где классы упрощают автодополнение и делают код безопаснее.

ООП особенно полезно для построения сложных архитектур с насыщенной бизнес-логикой.

Важно: для небольших утилит и простых скриптов функциональный стиль может быть эффективнее — он компактнее и проще в поддержке.

</details>

---

<details>
<summary><span>13. Что такое <b>композиция</b>?</span></summary>
<br />

Композиция — это принцип проектирования, при котором поведение объектов формируется путём объединения других объектов или функций, а не через наследование. Вместо создания вложенных иерархий, компоненты "собираются" из меньших строительных блоков.

Преимущества композиции:

- Более гибкая структура кода.
- Лёгкая переиспользуемость и замена частей.
- Упрощённое тестирование и сопровождение.

Пример: вместо класса `AuthUser`, наследующего `User`, можно создать объект `User` и "прикрепить" к нему логику авторизации как отдельный модуль.

</details>

---

<details>
<summary><span>14. Когда использовать композицию, а когда наследование?</span></summary>
<br />

Выбор между композицией и наследованием зависит от задач и гибкости архитектуры:

**Композиция** - стоит использовать, когда:

- нужны гибкие и переиспользуемые блоки логики,
- поведение должно задаваться динамически,
- объекты состоят из независимых частей (например, пользователь с разными ролями).

**Наследование** - уместно, когда:

- существует чёткая иерархия объектов,
- базовая логика должна расширяться, но не изменяться,
- необходимо переиспользовать поведение в подклассах.

💡 Обычно композиция предпочтительнее — она снижает связанность, делает код модульным и лучше сочетается с современными подходами (например, хуками в Vue или React).

</details>

---

<details>
<summary><span>15. Почему надо быть осторожным с наследованием?</span></summary>
<br />

Наследование может привести к излишней связанности и хрупкости системы. Изменения в базовом классе автоматически затрагивают все подклассы, что повышает риск непредвиденных багов. Также наследование часто провоцирует глубокие и запутанные иерархии, усложняющие сопровождение и тестирование.

Кроме того:

- Может нарушаться инкапсуляция.
- Подклассы становятся зависимыми от внутренней логики родителя.
- Трудно переиспользовать логику без дублирования.

💡 В современных приложениях, как правило, используют **не более одного уровня наследования**, отдавая предпочтение композиции — она гибче и проще в сопровождении.

</details>

---

<details>
<summary><span>16. Какую роль играет файл <b>.editorconfig</b> и почему он может быть важен в проекте?</span></summary>
<br />

Файл `.editorconfig` позволяет задать единые правила оформления кода для всех участников команды — от отступов и кодировки до способа окончания строк. Это помогает сохранить консистентность стиля во всём проекте, особенно если разработчики используют разные редакторы.

Хотя `.editorconfig` напрямую не влияет на архитектуру, он косвенно поддерживает её чистоту — единый стиль упрощает чтение, понимание и сопровождение кода, а значит снижает риски для архитектурных решений.

</details>

---

<details>
<summary><span>17. Для чего нужны <b>прекоммит-хуки</b>?</span></summary>
<br />

Прекоммит-хуки — это скрипты, которые автоматически запускаются перед коммитом в Git. Они помогают проверить и подготовить изменения до того, как они попадут в репозиторий.

Зачем они нужны:

- Проверка качества кода (линтинг, форматирование).
- Запуск тестов — чтобы не закоммитить баги.
- Удаление временных или лишних файлов.
- Соблюдение единых стандартов в команде.

Хотя прекоммит-хуки не влияют напрямую на архитектуру, они **поддерживают стабильность проекта** и помогают избежать случайных или плохих изменений в коде.

</details>

---

<details>
<summary><span>18. Тесты лучше запускать на препуше или на прекоммит?</span></summary>
<br />

Тесты лучше запускать на <b>препуше</b>, а не на прекоммите.

Почему:

- Прекоммит должен быть быстрым — он запускается часто, и долгие тесты могут мешать работе.
- Препуш запускается реже (только перед отправкой изменений на сервер), поэтому там уместно проверять, что всё действительно работает.

Такой подход экономит время и сохраняет качество кода.

</details>

---

<details>
<summary><span>19. В чём смысл сборки фронтенд-приложения и зачем используется сборщик?</span></summary>
<br />

**Сборка** — это процесс преобразования исходного кода в финальную версию, готовую для запуска в браузере. Сборщик (например, `Vite`, `Webpack`) помогает объединить модули, стили, изображения и другие ресурсы в оптимизированный пакет.

**Зачем это нужно:**

- **Минификация** — удаление лишнего кода и уменьшение размера файлов.
- **Объединение модулей** — сокращает количество сетевых запросов.
- **Преобразование синтаксиса** — поддержка современных технологий: `TypeScript`, `JSX`, `SCSS`.
- **Оптимизация производительности** — сжатие, кэширование, отложенная загрузка.
- **Удаление dev-кода** — исключение тестов, логов и других элементов, не нужных в продакшене.
- **Поддержка архитектуры** — сборщик помогает организовать проект: `alias`-ы, корректные импорты, соблюдение слоёв.

**Сборка** — это не просто упаковка, а ключевой этап подготовки **надёжного**, **быстрого** и **поддерживаемого** фронтенд-приложения.

</details>

---

<details>
<summary><span>20. Почему Webpack до сих пор активно используется, хотя есть более быстрые сборщики?</span></summary>
<br />

- **Мощная настройка** — позволяет контролировать процесс сборки до мельчайших деталей.
- **Глубокая интеграция** — многие крупные проекты и библиотеки (особенно корпоративные) уже используют Webpack.
- **Широкая экосистема** — большое количество плагинов, лоадеров и готовых решений
- **Совместимость с разными технологиями** — легко подружить с `TypeScript`, `React`, `Vue`, `SCSS` и другими.
- **Универсальность** — подходит как для frontend, так и для backend-сборки.
- **Поддержка Webpack Module Federation** — востребовано в сложных микрофронтендах.

Хотя современные сборщики быстрее и проще в освоении, Webpack остаётся надёжным выбором для проектов с нестандартными требованиями или сложной архитектурой.

</details>

---

<details>
<summary><span>21. Можно ли файл <b>.env</b> с переменными коммитить в репозиторий?</span></summary>
<br />

В большинстве случаев файл `.env` **не следует коммитить** в репозиторий, особенно если он содержит **секретные данные**: токены, пароли, ключи API и прочую конфиденциальную информацию.

Утечка ключей может привести к взлому системы или потере ресурсов.

Поэтому файл `.env` следует добавлять в `.gitignore`, чтобы он не попадал в репо.

Исключения возможны, если `.env` не содержит чувствительных данных и нужен для тестов, но даже тогда лучше быть осторожным.

</details>

---

<details>
<summary><span>22. Когда можно использовать секретный ключ в .env файле?</span></summary>
<br />

Секретный ключ можно использовать в `.env` файле, **если он не попадает в финальную сборку приложения** и обрабатывается только на серверной стороне. Такие переменные не должны быть доступны в браузере или клиентском JavaScript.

Если ключ используется в клиентском коде (например, в `.env.public`), его нужно либо зашифровать, либо заменить на промежуточные прокси-решения.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />

</details>

--- -->
