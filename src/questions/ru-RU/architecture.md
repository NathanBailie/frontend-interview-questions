<a href="./README.md">← Назад</a>

<div align="center">
  <img src="../../assets/icons/icons-for-titles/architecture.png">
  <h2>Архитектура</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>архитектура</b>?</span></summary>
<br />

**Архитектура** — это структурный подход к построению приложения, определяющий взаимодействие компонентов, обработку данных, масштабируемость и удобство сопровождения.

Можно сказать, что это совокупность ключевых решений, принятых на этапе проектирования, которые впоследствии сложно изменить — именно они задают вектор развития всей системы.

</details>

---

<details>
<summary><span>2. Какие основные проблемы должна решать архитектура?</span></summary>
<br />

Архитектура должна снижать зацепленность (coupling) — то есть минимизировать количество зависимостей между частями системы, — и одновременно управлять связанностью (cohesion), обеспечивая логичное объединение связанных элементов. Это позволяет системе быть гибкой, масштабируемой и легко расширяемой.

Также архитектура решает вопросы разделения ответственности, управляемости, тестируемости и устойчивости к изменениям.

</details>

---

<details>
<summary><span>3. Какие есть <b>атрибуты качества архитектуры</b> ?</span></summary>
<br />

Ключевые атрибуты качества архитектуры включают:

- **Читаемость (readability)** — облегчает понимание структуры и логики кода.
- **Переиспользуемость (reusability)** — позволяет использовать компоненты повторно без дублирования.
- **Слабая связанность и высокая зацепленность** — минимизируют зависимости и повышают устойчивость к изменениям.
- **Гибкость (flexibility)** — упрощает адаптацию архитектуры под меняющиеся бизнес-требования.
- **Надёжность (reliability)** — достигается через тестирование, ревью и контроль ошибок.
- **Поддерживаемость (maintainability)** — позволяет эффективно развивать и исправлять систему.
- **Тестируемость (testability)** — упрощает написание и выполнение тестов.

</details>

---

<details>
<summary><span>4. Почему вообще стоит задумываться над архитектурой?</span></summary>
<br />

Хорошая архитектура помогает создавать систему, которую проще масштабировать, сопровождать и адаптировать под новые требования. Она обеспечивает устойчивость к изменениям и упрощает командную работу.

Без архитектурного фундамента проект может быстро превратиться в хаос: правки становятся рискованными, развитие — замедляется, а сопровождение требует всё больше усилий.

</details>

---

<details>  
<summary><span>5. Какие вы знаете <b>принципы</b> и <b>методологии разработки</b>?</span></summary>  
<br />

- **DRY (Don’t Repeat Yourself)** — избегай дублирования кода и логики, выноси повторяющееся в отдельные единицы.
- **KISS (Keep It Simple, Stupid)** — простота важнее излишней умности, решения должны быть понятными и лаконичными.
- **SOC (Separation of Concerns)** — разделение ответственности: каждая часть системы должна заниматься своей задачей.
- **FF (Fail Fast)** — чем раньше система сообщает об ошибке, тем проще её отловить и устранить.
- **YAGNI (You Ain’t Gonna Need It)** — не стоит реализовывать то, что не требуется прямо сейчас.
- **SOLID** — методология построения надёжного и расширяемого ООП-кода, основанная на пяти принципах (Single Responsibility, Open/Closed и пр.).
- **TDD (Test-Driven Development)** — разработка через тестирование: сначала пишутся тесты, потом код, удовлетворяющий этим тестам.
- **TDA (Test-Driven Architecture)** — архитектура проектируется с учётом тестируемости, часто в связке с TDD.
- **DDD (Domain-Driven Design)** — проектирование вокруг предметной области, где архитектура отражает бизнес-логику.

Эти подходы помогают создавать код, который проще масштабировать, сопровождать и адаптировать.

</details>

---

<details>
<summary><span>6. Объясните принципы <b>SOLID</b>?</span></summary>
<br />

- **S — Single Responsibility Principle (SRP)**: каждый модуль должен отвечать только за одну часть функциональности, работая в одном домене
- **O — Open/Closed Principle (OCP)**: код должен быть открыт для расширения, но закрыт для модификации.
- **L — Liskov Substitution Principle (LSP)**: подклассы должны полноценно заменять базовые классы без нарушения логики.
- **I — Interface Segregation Principle (ISP)**: не стоит заставлять объект реализовывать интерфейс, который ему не нужен.
- **D — Dependency Inversion Principle (DIP)**: зависимости должны строиться от абстракций, а не от конкретных реализаций.

</details>

---

<details>  
<summary><span>7. Что такое чистая <b>архитектура</b>?</span></summary>  
<br />

**Чистая архитектура** — это подход к проектированию системы, при котором бизнес-логика отделена от инфраструктуры, пользовательского интерфейса и других внешних слоёв. Архитектура строится вокруг независимых слоёв, где зависимости направлены внутрь — к ядру приложения.

**Основные идеи:**

- В центре — бизнес-правила: сущности (Entities) и сценарии использования (Use Cases).
- Внешние слои (UI, базы данных, фреймворки) легко заменяемы.
- Связь между слоями осуществляется через абстракции (интерфейсы), реализуя принцип инверсии зависимостей.

Такой подход делает проект гибким, легко тестируемым и устойчивым к изменениям во внешней среде.

</details>

---

<details>
<summary><span>8. Из чего состоит <b>Атомарная архитектура</b>?</span></summary>
<br />

Атомарная архитектура — это подход к организации UI компонентов, основанный на принципах Atomic Design. Он делит интерфейс на уровни абстракции:

- **Atoms** — базовые элементы: кнопки, инпуты, иконки.
- **Molecules** — простые композиции атомов, например, форма авторизации.
- **Organisms** — более сложные блоки, состоящие из молекул и атомов, например, хедер.
- **Templates** — макеты страниц с расставленными организмами.
- **Pages** — конкретные реализации шаблонов с реальными данными.

Такой подход повышает переиспользуемость компонентов и упрощает поддержку дизайна.

</details>

---

<details>
<summary><span>9. Как устроена <b>Feature-Sliced Design</b> архитектура?</span></summary>
<br />

Feature-Sliced Design (FSD) — это подход к построению фронтенд-архитектуры, ориентированный на масштабируемость и удобство сопровождения крупных проектов. Он базируется на разделении по бизнес-сущностям и уровням абстракции.

**Основные уровни:**

- **App** — конфигурация и глобальная инициализация приложения.
- **Processes** — сквозные бизнес-процессы (например, оформление заказа).
- **Pages** — конкретные страницы, связывающие UI и бизнес-логику.
- **Widgets** — составные блоки, объединяющие несколько фичей и UI-элементов.
- **Features** — независимые бизнес-функции (например, фильтр товаров).
- **Entities** — модели и логика бизнес-сущностей (например, пользователь, товар).
- **Shared** — общие утилиты, компоненты, типы и стили, доступные всем слоям.

**Ключевые архитектурные принципы:**

- **Разделение логики и UI** внутри каждого модуля: бизнес-логика и визуальное представление обособлены для гибкости и тестируемости.
- **Импорты через Public API** — доступ к внешним модулям осуществляется только через строго определённый публичный интерфейс (`index.ts`).
- **Односторонняя направленность зависимостей:** можно импортировать из нижележащего слоя в верхний, но не наоборот. Исключение — слой `shared`, который доступен всем.

</details>

---

<details>
<summary><span>10. Что такое декларативность?</span></summary>
<br />

Декларативность — это стиль программирования, при котором разработчик описывает **что** должно быть сделано, а не **как** это должно выполняться. Вместо явных шагов, управление передаётся среде выполнения или фреймворку.

Примеры:

- В HTML: `<button disabled>` — мы не описываем, как именно кнопка становится неактивной.
- В Vue: `v-if="isVisible"` — мы говорим, что элемент отображается при определённом условии, не управляя DOM вручную.

Такой подход упрощает чтение кода, повышает его выразительность и снижает количество ошибок при взаимодействии с низкоуровневыми деталями.

</details>

---

<details>
<summary><span>11. Опишите основные <b>принципы ООП</b></span></summary>
<br />

- **Инкапсуляция** — сокрытие внутренней реализации и предоставление публичного интерфейса. Данные защищены от прямого вмешательства извне.
- **Наследование** — возможность создавать новые классы на основе существующих, повторно используя логику и расширяя функциональность.
- **Полиморфизм** — единый интерфейс для разных типов объектов. Позволяет вызывать методы без знания точного типа объекта.
- **Абстракция** — выделение ключевых характеристик объекта и сокрытие сложных деталей. Фокус на том, что важно, а не как это реализовано.

</details>

---

<details>
<summary><span>12. Когда стоит использовать ООП?</span></summary>
<br />

Объектно-ориентированное программирование (ООП) стоит использовать, когда:

- система содержит множество похожих сущностей с общими свойствами и поведением (например, пользователи, товары, заказы),
- требуется чёткое моделирование структуры и взаимодействий внутри приложения,
- проект большой и предполагает долгосрочное развитие,
- необходимо легко расширять и переиспользовать код (через наследование, интерфейсы и абстракции),
- используется язык с типизацией (например, TypeScript), где классы упрощают автодополнение и делают код безопаснее.

ООП особенно полезно для построения сложных архитектур с насыщенной бизнес-логикой.

Важно: для небольших утилит и простых скриптов функциональный стиль может быть эффективнее — он компактнее и проще в поддержке.

</details>

---

<details>
<summary><span>13. Что такое <b>композиция</b>?</span></summary>
<br />

Композиция — это принцип проектирования, при котором поведение объектов формируется путём объединения других объектов или функций, а не через наследование. Вместо создания вложенных иерархий, компоненты "собираются" из меньших строительных блоков.

Преимущества композиции:

- Более гибкая структура кода.
- Лёгкая переиспользуемость и замена частей.
- Упрощённое тестирование и сопровождение.

Пример: вместо класса `AuthUser`, наследующего `User`, можно создать объект `User` и "прикрепить" к нему логику авторизации как отдельный модуль.

</details>

---

<details>
<summary><span>14. Когда использовать композицию, а когда наследование?</span></summary>
<br />

Выбор между композицией и наследованием зависит от задач и гибкости архитектуры:

**Композиция** - стоит использовать, когда:

- нужны гибкие и переиспользуемые блоки логики,
- поведение должно задаваться динамически,
- объекты состоят из независимых частей (например, пользователь с разными ролями).

**Наследование** - уместно, когда:

- существует чёткая иерархия объектов,
- базовая логика должна расширяться, но не изменяться,
- необходимо переиспользовать поведение в подклассах.

💡 Обычно композиция предпочтительнее — она снижает связанность, делает код модульным и лучше сочетается с современными подходами (например, хуками в Vue или React).

</details>

---

<details>
<summary><span>15. Почему надо быть осторожным с наследованием?</span></summary>
<br />

Наследование может привести к излишней связанности и хрупкости системы. Изменения в базовом классе автоматически затрагивают все подклассы, что повышает риск непредвиденных багов. Также наследование часто провоцирует глубокие и запутанные иерархии, усложняющие сопровождение и тестирование.

Кроме того:

- Может нарушаться инкапсуляция.
- Подклассы становятся зависимыми от внутренней логики родителя.
- Трудно переиспользовать логику без дублирования.

💡 В современных приложениях, как правило, используют **не более одного уровня наследования**, отдавая предпочтение композиции — она гибче и проще в сопровождении.

</details>

---

<details>
<summary><span>16. Какую роль играет файл <b>.editorconfig</b> и почему он может быть важен в проекте?</span></summary>
<br />

Файл `.editorconfig` позволяет задать единые правила оформления кода для всех участников команды — от отступов и кодировки до способа окончания строк. Это помогает сохранить консистентность стиля во всём проекте, особенно если разработчики используют разные редакторы.

Хотя `.editorconfig` напрямую не влияет на архитектуру, он косвенно поддерживает её чистоту — единый стиль упрощает чтение, понимание и сопровождение кода, а значит снижает риски для архитектурных решений.

</details>

---

<details>
<summary><span>17. Для чего нужны <b>прекоммит-хуки</b>?</span></summary>
<br />

Прекоммит-хуки — это скрипты, которые автоматически запускаются перед коммитом в Git. Они помогают проверить и подготовить изменения до того, как они попадут в репозиторий.

Зачем они нужны:

- Проверка качества кода (линтинг, форматирование).
- Запуск тестов — чтобы не закоммитить баги.
- Удаление временных или лишних файлов.
- Соблюдение единых стандартов в команде.

Хотя прекоммит-хуки не влияют напрямую на архитектуру, они **поддерживают стабильность проекта** и помогают избежать случайных или плохих изменений в коде.

</details>

---

<details>
<summary><span>18. Тесты лучше запускать на препуше или на прекоммит?</span></summary>
<br />

Тесты лучше запускать на <b>препуше</b>, а не на прекоммите.

Почему:

- Прекоммит должен быть быстрым — он запускается часто, и долгие тесты могут мешать работе.
- Препуш запускается реже (только перед отправкой изменений на сервер), поэтому там уместно проверять, что всё действительно работает.

Такой подход экономит время и сохраняет качество кода.

</details>

---

<details>
<summary><span>19. В чём смысл сборки фронтенд-приложения и зачем используется сборщик?</span></summary>
<br />

**Сборка** — это процесс преобразования исходного кода в финальную версию, готовую для запуска в браузере. Сборщик (например, `Vite`, `Webpack`) помогает объединить модули, стили, изображения и другие ресурсы в оптимизированный пакет.

**Зачем это нужно:**

- **Минификация** — удаление лишнего кода и уменьшение размера файлов.
- **Объединение модулей** — сокращает количество сетевых запросов.
- **Преобразование синтаксиса** — поддержка современных технологий: `TypeScript`, `JSX`, `SCSS`.
- **Оптимизация производительности** — сжатие, кэширование, отложенная загрузка.
- **Удаление dev-кода** — исключение тестов, логов и других элементов, не нужных в продакшене.
- **Поддержка архитектуры** — сборщик помогает организовать проект: `alias`-ы, корректные импорты, соблюдение слоёв.

**Сборка** — это не просто упаковка, а ключевой этап подготовки **надёжного**, **быстрого** и **поддерживаемого** фронтенд-приложения.

</details>

---

<details>
<summary><span>20. Почему Webpack до сих пор активно используется, хотя есть более быстрые сборщики?</span></summary>
<br />

- **Мощная настройка** — позволяет контролировать процесс сборки до мельчайших деталей.
- **Глубокая интеграция** — многие крупные проекты и библиотеки (особенно корпоративные) уже используют Webpack.
- **Широкая экосистема** — большое количество плагинов, лоадеров и готовых решений
- **Совместимость с разными технологиями** — легко подружить с `TypeScript`, `React`, `Vue`, `SCSS` и другими.
- **Универсальность** — подходит как для frontend, так и для backend-сборки.
- **Поддержка Webpack Module Federation** — востребовано в сложных микрофронтендах.

Хотя современные сборщики быстрее и проще в освоении, Webpack остаётся надёжным выбором для проектов с нестандартными требованиями или сложной архитектурой.

</details>

---

<details>
<summary><span>21. Можно ли файл <b>.env</b> с переменными коммитить в репозиторий?</span></summary>
<br />

В большинстве случаев файл `.env` **не следует коммитить** в репозиторий, особенно если он содержит **секретные данные**: токены, пароли, ключи API и прочую конфиденциальную информацию.

Утечка ключей может привести к взлому системы или потере ресурсов.

Поэтому файл `.env` следует добавлять в `.gitignore`, чтобы он не попадал в репо.

Исключения возможны, если `.env` не содержит чувствительных данных и нужен для тестов, но даже тогда лучше быть осторожным.

</details>

---

<details>
<summary><span>22. Когда можно использовать секретный ключ в .env файле?</span></summary>
<br />

Секретный ключ можно использовать в `.env` файле, **если он не попадает в финальную сборку приложения** и обрабатывается только на серверной стороне. Такие переменные не должны быть доступны в браузере или клиентском JavaScript.

Если ключ используется в клиентском коде (например, в `.env.public`), его нужно либо зашифровать, либо заменить на промежуточные прокси-решения.

</details>

---

<details>
<summary><span>23. Какие существуют <b>парадигмы программирования</b>?</span></summary>
<br />

Парадигмы программирования — это подходы к организации кода и построению логики приложения. Каждая парадигма задаёт свой стиль мышления и проектирования.

**Основные парадигмы:**

- **Императивная** — описывает _как_ достичь цели с помощью последовательных шагов. Примеры: `JavaScript`, `C`.
- **Процедурная** — разновидность императивной, делает упор на использование функций и процедур. Примеры: `Pascal`, `C`.
- **Декларативная** — описывает _что_ должно быть сделано, а не _как_. Примеры: `HTML`, `SQL`, шаблоны во `Vue`.
- **Объектно-ориентированная (ООП)** — строится вокруг объектов с состоянием и поведением. Использует классы, наследование и полиморфизм.
- **Функциональная** — делает акцент на чистые функции, неизменяемость данных и композицию. Примеры: `Haskell`, `Elm`, `Ramda.js`.
- **Событийно-ориентированная** — поведение строится вокруг обработки событий. Часто используется в UI и асинхронных системах.
- **Реактивная** — отслеживает изменения данных во времени и автоматически обновляет зависимые элементы (например, интерфейс). Примеры: `RxJS`, реактивность во `Vue`.
- **Логическая** — основана на правилах и логических выводах вместо явных инструкций. Пример: `Prolog`.

Современные языки часто поддерживают **мультипарадигменный подход**, позволяя сочетать несколько стилей (например, `TypeScript` сочетает ООП, функциональный и реактивный подходы).

</details>

---

<details>
<summary><span>24. Чем фреймворк лучше нативного JavaScript?</span></summary>
<br />

Фреймворки упрощают разработку за счёт готовой архитектуры, реактивности и инструментов, которые пришлось бы реализовывать вручную в чистом JavaScript.

**Преимущества фреймворка:**

- **Оптимизация DOM-операций** — виртуальный DOM и реактивность снижают количество ручных манипуляций, ускоряют интерфейс.
- **Расширяемость компонентов** — вместо наследования используются механизмы компоновки (composition) и сборки, что делает архитектуру гибче.
- **Упрощение логики** — не нужно вручную реализовывать состояние, связи между компонентами и механизм обновлений.
- **Удобный API для взаимодействия** — декларативный подход позволяет легко управлять жизненным циклом, передавать данные и компоновать UI.

Фреймворк — это не просто синтаксис, а **среда с лучшими практиками**, архитектурой и поддержкой, что позволяет фокусироваться на бизнес-логике, а не на рутинной работе.

</details>

---

<details>
<summary><span>25. Какие основные проблемы решает <b>фронтенд</b>?</span></summary>
<br />

Фронтенд — это не просто отрисовка кнопок, а целая система, решающая множество технических задач для создания удобных, быстрых и отзывчивых интерфейсов.

**Ключевые задачи, которые решает фронтенд:**

- **Оптимизация работы с DOM** — прямые манипуляции с DOM могут быть дорогими по ресурсам. Для повышения производительности применяются виртуальный DOM, реактивность и декларативные шаблоны.
- **Роутинг** — управление отображением различных страниц и состояний без перезагрузки (SPA). Современные фреймворки предоставляют удобные механизмы маршрутизации.
- **Управление состоянием** — централизованное хранилище (`store`) позволяет синхронизировать данные между компонентами (например, `Pinia`, `Vuex`, `Redux`).
- **Коммуникация между компонентами** — используются механизмы вроде `props`, событий, `provide/inject`, `composables` для связи между частями интерфейса без жёсткой связанности.
- **Организация архитектуры** — фронтенд определяет, как структурировать проект: по слоям, по фичам, с разделением логики и представления.
- **Пользовательский опыт (UX)** — анимации, отклики интерфейса, адаптивность под разные устройства и состояния пользователя реализуются на фронте.
- **Работа с асинхронностью и API** — фронтенд получает данные с сервера, обрабатывает загрузки, ошибки и обновляет интерфейс в режиме реального времени.

Современные фреймворки и библиотеки помогают решать эти задачи эффективно, делая интерфейсы не только красивыми, но и быстрыми, масштабируемыми и удобными для поддержки.

</details>

---

<details>
<summary><span>26. Какие концептуальные <b>различия между фреймворками</b> на фронте?</span></summary>
<br />

Фронтенд-фреймворки (`Vue`, `React`, `Angular`, `Svelte`, `Solid`) решают схожие задачи: управление интерфейсом, состоянием, роутингом, реактивностью и т.д.  
Но делают это по-разному — отличаясь архитектурой, философией и подходами к разработке.

**Ключевые концептуальные различия:**

- **Архитектурный подход**

  - `Vue` — декларативность, шаблоны (`template`) + `Composition API`, гибкая архитектура. FSD (feature-sliced design) ложится органично.
  - `React` — функциональный стиль, всё через `JSX`, логика и разметка объединены, архитектура гибкая, формируется вручную.
  - `Angular` — строгая архитектура: MVC, DI (внедрение зависимостей), аннотации и модули. Ориентирован на корпоративные приложения.
  - `Svelte` — компилируемый фреймворк, без виртуального DOM, с минимальной абстракцией.
  - `Solid` — fine-grained реактивность, максимальная производительность, JSX-подход как у React, но без виртуального DOM.

- **Связь шаблона и логики**

  - `Vue` — шаблон + логика разделены (`template`, `script`, `style`).
  - `React` — логика и разметка объединены в `JSX`.
  - `Angular` — шаблоны в отдельных HTML-файлах, логика в `TypeScript`-классах.
  - `Svelte` — структура похожа на `Vue`, но компилируется.
  - `Solid` — логика в `JSX`, как у React, но реактивность более низкоуровневая.

- **Состояние и реактивность**

  - `Vue` — встроенная реактивность через `ref`, `reactive`.
  - `React` — хук-подход (`useState`, `useEffect`), перерендер всего компонента.
  - `Angular` — императивный подход, с возможностью использовать `RxJS`.
  - `Svelte / Solid` — реактивность на уровне переменных, без перерендера всего компонента.

- **Коммуникация между компонентами**

  - `Vue` — `props`, события, `provide/inject`, `composables`.
  - `React` — `props`, `context`, кастомные хуки.
  - `Angular` — `@Input`, `@Output`, сервисы.
  - `Svelte / Solid` — `props`, контексты, функции и реактивные переменные.

- **Типизация и строгая структура**

  - `Vue` — гибкий, можно использовать TypeScript, но не обязательно.
  - `React` — полностью совместим с TypeScript.
  - `Angular` — строго типизированный (TypeScript обязателен).
  - `Svelte` — поддерживает TypeScript, но гибко.
  - `Solid` — заточен под TypeScript, API дружелюбен к типизации.

- **Размер и производительность**

  - `Svelte / Solid` — минимальный размер бандла, высокая производительность за счёт компиляции.
  - `Vue / React` — умеренный размер, хорошо оптимизируются.
  - `Angular` — самый тяжёлый, но масштабируемый для больших команд и проектов.

- **Зрелость и сообщество**
  - `React / Vue / Angular` — зрелые, с большим сообществом и экосистемой.
  - `Svelte / Solid` — моложе, стремительно развиваются, фокус на производительности.

---

💡 **Итог**: все фреймворки решают одни и те же задачи (UI, состояние, взаимодействие), но делают это по-своему. Выбор зависит от:

- требований проекта,
- размера команды,
- предпочтений по архитектуре (строгость vs гибкость),
- уровня перформанса и типизации.

</details>

---

<details>
<summary><span>27. Когда имеет смысл брать готовый шаблон из UI-библиотеки?</span></summary>
<br />

Готовые шаблоны из UI-библиотек стоит использовать, когда важно быстро создать интерфейс с минимальными затратами на дизайн, вёрстку и тестирование компонентов.

**Имеет смысл использовать шаблон, если:**

- **Нужна высокая скорость разработки** — шаблон помогает быстро собрать интерфейс без проработки стилей с нуля.
- **Проект не требует уникального дизайна** — например, для админок, MVP, дашбордов или внутренних систем.
- **Важно сохранить визуальную консистентность** — готовые шаблоны обеспечивают единый стиль и поведение всех компонентов.
- **Компоненты сложные по логике** — таблицы с пагинацией, формы с валидацией, модалки, селекты — такие вещи проще брать готовыми.
- **Маленькая команда или нет дизайнера** — библиотека берёт на себя ответственность за визуальную часть.

**Когда лучше отказаться от шаблона:**

- Когда нужен кастомный UI, строго соответствующий бренду и дизайну.
- Если библиотека тянет за собой лишние зависимости и увеличивает размер бандла.
- Когда кастомизация шаблона сложнее и дольше, чем реализация компонента с нуля.

💡 **Компромиссный подход** — использовать UI-библиотеку как основу, кастомизируя только то, что важно для UX и визуального стиля проекта.

</details>

---

<details>
<summary><span>28. Что такое <b>паттерн</b>?</span></summary>
<br />

**Паттерн** — это типовое, хорошо зарекомендовавшее себя решение для часто возникающей задачи или архитектурной ситуации. Это не конкретный код, а **абстрактная модель** или идея, которую можно адаптировать под разные языки и проекты.

</details>

---

<details>
<summary><span>29. Коротко опишите популярные <b>GOF</b> паттерны</span></summary>
<br />

**Порождающие паттерны:**

- **Singleton (Одиночка)** — гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальный доступ.
- **Factory Method (Фабричный метод)** — создание объектов через интерфейс, скрывая конкретные классы, которые создаются.
- **Builder (Строитель)** — пошаговая сборка сложного объекта с разными конфигурациями.
- **Abstract Factory (Абстрактная фабрика)** — создание групп связанных объектов без указания их конкретных классов.

**Структурные паттерны:**

- **Adapter (Адаптер)** — позволяет использовать несовместимые интерфейсы, оборачивая один интерфейс в другой.
- **Facade (Фасад)** — предоставляет упрощённый интерфейс к сложной системе, скрывая её внутреннюю реализацию.
- **Decorator (Декоратор)** — добавляет объекту новое поведение без изменения его структуры.
- **Proxy (Прокси)** — объект-заместитель, контролирующий доступ к другому объекту (например, кеш, логирование, защита).
- **Composite (Компоновщик)** — позволяет работать с древовидной структурой объектов как с единым целым.

**Поведенческие паттерны:**

- **Observer (Наблюдатель)** — оповещает подписанные объекты об изменении состояния наблюдаемого объекта.
- **Mediator (Медиатор)** — централизует коммуникацию между объектами, уменьшая связанность между ними.
- **Strategy (Стратегия)** — определяет семейство алгоритмов и позволяет подставлять нужный во время исполнения.
- **Iterator (Итератор)** — предоставляет единый способ перебора элементов коллекции, не раскрывая её внутреннюю структуру.
- **Command (Команда)** — инкапсулирует действие и его параметры, позволяя откладывать, логировать или отменять выполнение.

💡 Эти паттерны описаны в книге _Design Patterns: Elements of Reusable Object-Oriented Software_ (авторы — "Банда четырёх", GoF) и до сих пор применяются в проектировании архитектур, API и UI.

</details>

---

<details>
<summary><span>30. Что такое <b>coverage</b> и для чего оно нужно в проекте?</span></summary>
<br />

**Coverage (покрытие тестами)** — это метрика, показывающая, какая часть исходного кода была выполнена во время запуска тестов. Измеряется в процентах и помогает понять, насколько полно проверена логика приложения.

**Что показывает coverage:**

- Покрытие функций, условий, веток (`if/else`), циклов и отдельных строк.
- Какие участки кода были действительно выполнены при тестировании.
- Где остались "дыры" — непроверенные участки логики.

**Зачем нужен coverage:**

- Помогает оценить надёжность тестов и найти недостающие кейсы.
- Облегчает рефакторинг — видно, какие участки защищены тестами.
- Повышает стандарты качества — можно задать минимальный порог (например, 80%).

💡 Важно: **высокий coverage не гарантирует качество тестов**, но его отсутствие почти всегда говорит о рисках.

</details>

---

<details>
<summary><span>31. Что такое <b>dependency injection</b>?</span></summary>
<br />

**Dependency Injection (внедрение зависимостей)** — это паттерн, при котором объект получает свои зависимости (другие объекты, сервисы и т.п.) извне, а не создаёт их сам.

**Зачем нужен DI:**

- **Разделение ответственности** — объект не управляет созданием зависимостей, а просто использует их.
- **Тестируемость** — можно легко подменить зависимости на заглушки или моки.
- **Гибкость и масштабируемость** — удобно менять реализацию зависимостей без изменения основного кода.
- **Инверсия управления (IoC)** — контроль над созданием объектов передаётся внешней системе.

**Пример (псевдокод):**

```ts
// Без DI — объект сам создаёт зависимость
class UserService {
	constructor() {
		this.api = new ApiClient();
	}
}

// С DI — зависимость передаётся извне
class UserService {
	constructor(apiClient) {
		this.api = apiClient;
	}
}
```

</details>

---

<details>
<summary><span>32. Для чего используются <b>динамические импорты компонентов</b>?</span></summary>
<br />

**Динамический импорт** — это способ загружать компоненты только при необходимости, а не во время начальной загрузки приложения. Это важно для оптимизации производительности и управления размером бандла.

**Зачем использовать динамические импорты:**

- **Lazy-loading** — компоненты загружаются по требованию (например, при переходе на страницу), сокращая размер первого запроса.
- **Разделение кода (code-splitting)** — позволяет разбить приложение на независимые чанки, загружаемые отдельно.
- **Снижение нагрузки на клиента** — неиспользуемые компоненты не тянут ресурсы до тех пор, пока не понадобятся.
- **Ускорение первого рендера** — только критически важный код загружается сразу, остальное — позже.

**Примеры:**
**Vue 3:**

```js
const ProfilePage = defineAsyncComponent(() => import('@/pages/Profile.vue'));
```

**React:**

```js
export const SettingsPage = lazy(() => import('./SettingsPage'));
```

</details>

---

<details>
<summary><span>33. Что такое <b>шаблонный метод</b>?</span></summary>
<br />

**Шаблонный метод (Template Method)** — это поведенческий паттерн, который определяет общую последовательность шагов алгоритма, оставляя детали реализации для подклассов. Он задаёт структуру, а конкретные шаги могут переопределяться.

**Зачем используется:**

- Обеспечивает **контроль над алгоритмом**, позволяя переопределять только нужные части.
- Устраняет **дублирование** — общая логика оформлена в базовом классе.
- Способствует **расширяемости**, не ломая архитектуру.

**Пример:**

```ts
abstract class Page {
	render() {
		this.renderHeader();
		this.renderContent();
		this.renderFooter();
	}

	protected abstract renderContent(): void;

	private renderHeader() {
		console.log('Header');
	}

	private renderFooter() {
		console.log('Footer');
	}
}

class HomePage extends Page {
	protected renderContent() {
		console.log('Home content');
	}
}
```

💡 Page.render() — это шаблонный метод. Header и Footer фиксированы, а Content — переопределяется.

Итог: шаблонный метод — это способ задать "скелет" поведения, позволяя варьировать только определённые шаги, не изменяя структуру всего алгоритма.

</details>

---

<details>
<summary><span>34. Для чего используется <b>SSR</b> (Server-Side Rendering)?</span></summary>
<br />

**SSR (Server-Side Rendering)** — это техника, при которой HTML-страница генерируется на сервере, а не в браузере. Вместо загрузки пустого HTML и последующего рендеринга через JavaScript, клиент получает уже готовую HTML-разметку.

**Зачем используется SSR:**

- **Ускорение первого отображения страницы** — браузер сразу получает содержимое, без ожидания загрузки JS.
- **SEO-оптимизация** — поисковики лучше индексируют контент, если он сразу присутствует в HTML.
- **Снижение нагрузки на клиент** — особенно полезно на слабых устройствах или при медленном интернете.
- **Улучшение доступности и UX** — контент загружается быстрее, интерфейс выглядит стабильнее.

**Применяется в:**

- Витринных сайтах и маркетинговых страницах.
- Блогах, статьях, e-commerce проектах.
- Когда важно передать контент поисковикам и соцсетям быстро (например, для preview-карточек).

💡 SSR может сочетаться с SPA — это называется **гибридный рендеринг**, как в `Nuxt`, `Next.js`, `SvelteKit`.

</details>

---

<details>
<summary><span>35. Какие есть <b>недостатки у SSR</b>?</span></summary>
<br />

Несмотря на преимущества SSR (быстрый первый рендер, SEO, UX), у него есть и **существенные недостатки**, которые важно учитывать при выборе архитектуры.

**Недостатки SSR:**

- **Нагрузка на сервер** — каждое обращение требует генерации HTML на сервере, что увеличивает нагрузку при высоком трафике.
- **Сложность инфраструктуры** — нужен сервер или серверless-платформа для рендеринга, что усложняет деплой и масштабирование.
- **Увеличение времени отклика** — если сервер перегружен или сеть нестабильна, SSR может работать медленнее, чем SPA.
- **Меньшая интерактивность** — после загрузки HTML нужно выполнить гидратацию, что может тормозить работу интерфейса.
- **Сложности отладки и разработка** — SSR требует учёта окружения (`window`, `document` могут быть недоступны), что добавляет сложности в коде.
- **Больше нюансов в кэшировании** — важно грамотно настраивать кэш, иначе страницы будут перерендериваться слишком часто.

💡 SSR отлично подходит для публичных страниц, блогов, e-commerce, но может быть избыточным для внутренних SPA-интерфейсов или админок.

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />

</details>

--- -->

<!--
может ли быть несколько стейт менеджеров для 1 приложения

Если запретили стейт менеджер на проекте, что делать, предложи как можно больше вариантов
Я хочу открыть приложение в нескольких вкладках браузера, как синхронизировать приложение
Что такое jwt токен
Как он работает на стороне фронта
При авторизации используются два вида токена, что знаешь об этом
Как на фронте правильно хранить токен авторизации?
Какую задачу решают тесты?
зачем нужен package.json и package-lock.json?? Нужно ли коммитить lock-файл?
 -->
