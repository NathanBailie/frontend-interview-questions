<div align="center">
  <img src="../../assets/icons/icons-for-titles/vue.png">
  <h2>Vue</h2>
</div>
<br />

<details>
<summary><span>1. Что такое <b>Vue</b>?</span></summary>
<br />

Vue — это гибкий JavaScript-фреймворк для создания интерфейсов. Он предлагает реактивность, удобную работу с компонентами и отлично подходит для SPA.

</details>

---

<details>
<summary><span>2. Что такое <b>Virtual DOM</b>?</span></summary>
<br />

Virtual DOM — это «виртуальное» представление реального DOM в памяти. Вместо того чтобы сразу менять веб-страницу, Vue сначала вносит изменения в виртуальную копию, сравнивает её с предыдущей версией (diffing), а затем обновляет только изменённые части. Это делает работу интерфейса быстрее и плавнее.

</details>

---

<details>
<summary><span>3. Что такое <b>компонентный подход</b>?</span></summary>
<br />

Компонентный подход — это способ разработки интерфейсов, при котором приложение разбивается на независимые и многократно используемые части — компоненты. Каждый компонент отвечает за свою часть UI и логику, что делает код более понятным, гибким и удобным для сопровождения.

</details>

---

<details>
<summary><span>4. Можете описать <b>жизненный цикл</b> компонента?</span></summary>
<br />

Жизненный цикл компонента во Vue можно разбить на несколько фаз:

**1. Инициализация**

- `beforeCreate` — до инициализации данных и событий
- `created` — данные и события уже доступны

**2. Монтирование в DOM**

- `beforeMount` — перед вставкой шаблона в DOM
- `mounted` — компонент отрисован и доступен в DOM

**3. Обновление (при изменении реактивных данных)**

- `beforeUpdate` — перед обновлением DOM
- `updated` — после обновления DOM

**4. Размонтаж (удаление компонента)**

- `beforeUnmount` — перед удалением из DOM
- `unmounted` — после удаления

</details>

---

<details>
<summary><span>5. Что такое <b>директива</b>?</span></summary>
<br />

Директива — это специальный атрибут в шаблоне Vue, который расширяет HTML и добавляет динамическое поведение. Она начинается с префикса `v-` (например, `v-if`, `v-for`, `v-model`) и связывает DOM с логикой компонента.

Директивы позволяют управлять отображением, обработкой событий и многим другим.

</details>

---

<details>
<summary><span>6. Какие есть директивы?</span></summary>
<br />

Во Vue есть две группы директив:

**Стандартные директивы:**

- `v-if`, `v-else`, `v-else-if` — условный рендеринг
- `v-for` — циклический вывод
- `v-bind` — привязка атрибутов
- `v-model` — двусторонняя привязка данных
- `v-on` — обработка событий
- `v-show` — управление видимостью
- `v-slot` — передача слотов
- `v-pre`, `v-cloak`, `v-once` — особые инструкции для управления шаблоном

**Пользовательские директивы:**  
Можно создавать свои — например, `v-focus`, чтобы автоматически фокусироваться на элементе при загрузке.

</details>

---

<details>
<summary><span>7. Что такое <b>реактивность</b>?</span></summary>
<br />

Реактивность — это способность Vue автоматически отслеживать изменения в данных и обновлять интерфейс без ручного вмешательства. Когда вы изменяете реактивное значение, Vue сам «понимает», какие части DOM нужно перерисовать

В основе этого механизма — специальные реактивные обёртки (`ref`, `reactive`), которые следят за изменениями и запускают обновление компонента при необходимости.

</details>

---

<details>
<summary><span>8. Что такое <b>Composition API</b>?</span></summary>
<br />

Composition API — это способ организации логики компонентов во Vue 3. Вместо разделения по опциям (`data`, `methods`, `computed`), можно группировать связанную логику в функции и использовать реактивные примитивы (`ref`, `reactive`, `computed`, `watch`) прямо внутри `setup()`.

Это делает код более читаемым и переиспользуемым, особенно в больших приложениях.

</details>

---

<details>
<summary><span>9. Что такое <b>двустороннее связывание</b>?</span></summary>
<br />

Двустороннее связывание (two-way binding) — это когда данные и интерфейс синхронизируются автоматически в обе стороны: изменение в модели обновляет DOM, а пользовательский ввод — данные.

</details>

---

<details>
<summary><span>10. Как реализуется двустороннее связывание?</span></summary>
<br />

| Элемент                 | Событие  | Атрибут   |
| ----------------------- | -------- | --------- |
| `<input>`, `<textarea>` | `input`  | `value`   |
| `checkbox`, `radio`     | `change` | `checked` |
| `<select>` (списки)     | `change` | `value`   |

</details>

---

<details>
<summary><span>11. Какие есть <b>особенности использования v-model</b> в Vue 2 и Vue 3</span></summary>
<br />

Vue 2 поддерживает только одну связку `v-model` на компонент. Она работает с атрибутом `value` и слушает событие `input` — именно так данные синхронизируются между родителем и дочерним компонентом.

Во Vue 3 можно использовать несколько `v-model` одновременно с разными именами:

```html
<my-form
	v-model:inputValue="inputValue"
	v-model:visible="isVisible"
	v-model:contract="contractData"
/>
```

</details>

---

<details>
<summary><span>12. Как создать <b>кастомную директиву</b>?</span></summary>
<br />

В Vue 3 кастомные директивы создаются с помощью метода `app.directive`. Это позволяет добавить свою логику для работы с DOM-элементами напрямую.

**Пример: директива для автофокуса**

1. **Регистрация директивы:**

```js
app.directive('focus', {
	mounted(el) {
		el.focus();
	},
});
```

2. **Использование в шаблоне:**

```html
<input v-focus />
```

</details>

---

<details>
<summary><span>13. Является ли корневой div обязательным во Vue?</span></summary>
<br />

**Во Vue 2** — да, шаблон компонента должен иметь **один корневой элемент** (чаще всего это `div`). Если попытаться вернуть несколько элементов на одном уровне, будет ошибка.

**Во Vue 3** — нет, можно возвращать **несколько соседних элементов** без обёртки. Это называется поддержка фрагментов, и она позволяет упростить структуру шаблонов:

```vue
<template>
	<h1>Привет</h1>
	<p>Это компонент без обёртки</p>
</template>
```

</details>

---

<details>
<summary><span>14. Что такое <b>slot</b>?</span></summary>
<br />

`slot` — это специальное место в шаблоне компонента Vue, куда родитель может вставить произвольный контент. Это делает компонент гибким и переиспользуемым.

**Пример:**

```vue
<template>
	<div class="card">
		<slot></slot>
	</div>
</template>
```

```vue
<Card>
  <p>Это содержимое передано через слот</p>
</Card>
```

Здесь `<p>` из родительского компонента окажется внутри `.card` — именно туда, где расположен `<slot>`.

</details>

---

<details>
<summary><span>15. Какие бывают слоты?</span></summary>
<br />

Во Vue существуют несколько типов слотов, позволяющих гибко вставлять содержимое в компоненты:

**Обычный (неименованный) слот**  
Используется по умолчанию, если не указано иное:

```vue
<slot></slot>
```

**Именованные слоты**  
Позволяют вставлять контент в определённые места шаблона:

```vue
<slot name="header"></slot>
```

</details>

---

<details>
<summary><span>16. Как работает <b>условный рендеринг</b> во Vue?</span></summary>
<br />

Во Vue условный рендеринг используется для отображения или скрытия элементов DOM в зависимости от определённых условий. Основные директивы для этого — `v-if`, `v-else-if` и `v-else`.

- `v-if`: отображает элемент только в том случае, если выражение истинно.
- `v-else-if`: добавляется как альтернативное условие, если предыдущее `v-if` ложно.
- `v-else`: отрабатывает, если ни одно из предыдущих условий не выполнилось.

Пример:

```html
<p v-if="isLoggedIn">Добро пожаловать!</p>
<p v-else>Пожалуйста, войдите в систему.</p>
```

</details>

---

<details>
<summary><span>17. В чем разница между <b>v-if</b> и <b>v-show</b>?</span></summary>
<br />

`v-if` полностью добавляет или удаляет элемент из DOM, а `v-show` лишь переключает свойство `display` с помощью CSS.

</details>

---

<details>
<summary><span>18. Что такое <b>интерполяция</b>?</span></summary>
<br />

Это способ вставки данных из JavaScript в шаблон с помощью двойных фигурных скобок `{{ }}`.

Пример:

```html
<p>Привет, {{ username }}!</p>
```

</details>

---

<details>
<summary><span>19. Что такое <b>модификаторы</b>?</span></summary>
<br />

**Модификаторы** во Vue — это специальные суффиксы, добавляемые к директивам через точку (`.`), чтобы изменить их стандартное поведение.

Они часто используются с:

- **`v-on`** (обработка событий)
- **`v-model`** (двусторонняя привязка данных)

---

### Примеры модификаторов с `v-on`:

- `v-on:submit.prevent` — предотвращает стандартную отправку формы.
- `v-on:click.stop` — останавливает всплытие события (`stopPropagation`).
- `v-on:keydown.enter` — обработка только нажатия клавиши Enter.

---

### Примеры модификаторов с `v-model`:

- `v-model.lazy` — обновляет данные **только при событии `change`**, а не `input`.
- `v-model.trim` — автоматически **удаляет пробелы** в начале и конце строки.
- `v-model.number` — **преобразует ввод в число** (если возможно).

---

Директивы делают код чище и позволяют избежать написания лишней логики в обработчиках событий

</details>

---

<details>
<summary><span>20. Что делает флаг <b>scoped</b>?</span></summary>
<br />

Флаг `scoped` используется в тегах `<style>` в компонентах Vue, чтобы **ограничить применение CSS только к текущему компоненту**.

Если ты пишешь:

```vue
<style scoped>
h1 {
	color: red;
}
</style>
```

</details>

---

<details>
<summary><span>21. Что такое <b>наблюдаемые и вычисляемые свойства</b>?</span></summary>
<br />

Во Vue существуют два важных типа реактивных свойств:

---

### Наблюдаемые свойства (реактивные)

Это обычные переменные, созданные с помощью `ref()` или `reactive()`, которые Vue отслеживает и обновляет при изменении.

Пример:

```js
<script setup>
import { ref } from 'vue';

const count = ref(0);
</script>

<template>
  <button @click="count++">Clicked {{ count }} times</button>
</template>
```

При изменении `count.value` Vue автоматически обновляет DOM.

---

### Вычисляемые свойства (computed)

Это свойства, **зависящие от других реактивных значений**, и автоматически пересчитывающиеся при их изменении. Используются для создания производных значений, которые **кешируются**, пока зависимости не изменятся.

Пример:

```js
<script setup>
import { ref, computed } from 'vue';

const firstName = ref('Иван');
const lastName = ref('Иванов');

const fullName = computed(() => `${firstName.value} ${lastName.value}`);
</script>

<template>
  <p>{{ fullName }}</p>
</template>
```

`fullName` будет пересчитано только тогда, когда изменится `firstName` или `lastName`.

---

### Разница:

| Свойство           | Обновляется вручную | Кешируется | Используется для     |
| ------------------ | ------------------- | ---------- | -------------------- |
| `ref` / `reactive` | Да                  | Нет        | Хранение данных      |
| `computed`         | Нет (автоматически) | Да         | Производные значения |

</details>

---

<details>
<summary><span>22. <b>Как получить Dom-элемент</b> во Vue?</span></summary>
<br />

Во Vue для получения доступа к DOM-элементу используется **реф-ссылка** (`ref`) в шаблоне и `ref()` или `onMounted()` в скрипте.

---

### Шаги:

1. Добавить `ref="имя"` к нужному элементу в шаблоне.
2. В `<script setup>` или `setup()` получи доступ к DOM-элементу через `ref()`.

---

### Composition API:

```vue
<template>
	<input ref="myInput" />
</template>

<script setup>
import { ref, onMounted } from 'vue';

const myInput = ref(null);

onMounted(() => {
	myInput.value.focus();
});
</script>
```

---

### Важно:

- `myInput.value` будет `null`, пока компонент не смонтирован. Поэтому доступ к DOM лучше делать в `onMounted()`.
- Это работает и с компонентами. Если `ref` указывает на компонент, `value` будет содержать экземпляр компонента, а не DOM.

### Options API:

```vue
<template>
	<div ref="box"></div>
</template>

<script>
export default {
	mounted() {
		this.$refs.box.style.background = 'red';
	},
};
</script>
```

</details>

---

<details>
<summary><span>23. Как реализовать <b>ленивую загрузку</b> компонента или страницы?</span></summary>
<br />

Ленивая загрузка реализуется через `defineAsyncComponent` и динамический импорт в маршрутах `vue-router`.

**`defineAsyncComponent`**:

```js
import { defineAsyncComponent } from 'vue';

const LazyPage = defineAsyncComponent(() => import('./pages/LazyPage.vue'));
```

**Динамический импорт в маршрутах `vue-router`**

```js
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
	{
		path: '/about',
		component: () => import('./views/About.vue'),
	},
];

const router = createRouter({
	history: createWebHistory(),
	routes,
});
```

</details>

---

<details>
<summary><span>24. Что такое <b>keep-alive</b>?</span></summary>
<br />

`<keep-alive>` — это специальный компонент Vue, который позволяет **кэшировать компоненты**, чтобы сохранить их состояние при повторной активации.

Если переключаться между вкладками, маршрутами или компонентами, которые обёрнуты в `<keep-alive>`, Vue **не уничтожает** их, а "замораживает" в памяти. Это экономит ресурсы и ускоряет повторное отображение.

### Особенности:<br />

- Работает только с **динамическими компонентами** (`<component :is="...">`) или `router-view`.
- Можно использовать `include` / `exclude` для фильтрации кэшируемых компонентов.
- События жизненного цикла:
  - `activated()` — вызывается, когда компонент "просыпается".
  - `deactivated()` — вызывается, когда компонент "замораживается".

### Пример:

```vue
<keep-alive>
  <component :is="currentTabComponent" />
</keep-alive>
```

### Когда применять:

- Для вкладок (tabs), модалок, переключаемых форм и всего, где нужно сохранять состояние.
- Особенно полезно в SPA при переключении между страницами, чтобы не терять введённые данные.

</details>

---

<details>
<summary><span>25. Что такое <b>телепорт</b>?</span></summary>
<br />

Телепорт позволяет **рендерить часть шаблона в другое место DOM-дерева**, не нарушая логику компонента. Это особенно полезно для модалок, тултипов, всплывающих окон — всего, что должно визуально находиться в другом месте в структуре HTML (например, вне `#app`).

---

### Пример:

```vue
<teleport to="body">
  <div class="modal">
    Я появлюсь прямо в <body>!
  </div>
</teleport>
```

Здесь `to="body"` означает, что содержимое `<teleport>` будет вставлено в тег `<body>`, а не останется в текущей иерархии компонента.

</details>

---

<details>
<summary><span>26. Для чего нужен <b>key</b> при использовании директивы <b>v-for</b>?</span></summary>
<br />

Атрибут `key` в `v-for` нужен для того, чтобы Vue мог корректно и эффективно отслеживать изменения элементов списка и сохранять их состояние при обновлении DOM.

</details>

---

<details>
<summary><span>27. Как <b>принудительно обновить компонент</b> в Vue?</span></summary>
<br />

Во Vue можно принудительно обновить компонент с помощью `this.$forceUpdate()` (Options API) или изменением `:key` у компонента (Composition API).

</details>

---

<details>
<summary><span>28. Для чего нужно <b>Watch Api</b>?</span></summary>
<br />

Watch API используется для **реагирования на изменения реактивных данных** и выполнения побочных эффектов.

- **Vue 2:**

```js
watch: {
  count(newVal) {
    console.log('Счётчик изменился:', newVal)
  }
}
```

- **Vue 3:**

```js
watch(count, newVal => {
	console.log('Счётчик изменился:', newVal);
});
```

</details>

---

<!-- <details>
<summary><span></span></summary>
<br />


</details>

--- -->
